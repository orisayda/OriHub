{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/*! Source code licensed under Apache License 2.0. Copyright Â© 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Util } from \"./Util\";\nimport { Geom, Num } from \"./Num\";\nimport { Pt, Group } from \"./Pt\";\nimport { Mat } from \"./LinearAlgebra\";\n\nvar _errorLength = function _errorLength(obj) {\n  var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"expected\";\n  return Util.warn(\"Group's length is less than \" + param, obj);\n};\n\nvar _errorOutofBound = function _errorOutofBound(obj) {\n  var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  return Util.warn(\"Index \".concat(param, \" is out of bound in Group\"), obj);\n};\n\nexport var Line =\n/*#__PURE__*/\nfunction () {\n  function Line() {\n    _classCallCheck(this, Line);\n  }\n\n  _createClass(Line, null, [{\n    key: \"fromAngle\",\n    value: function fromAngle(anchor, angle, magnitude) {\n      var g = new Group(new Pt(anchor), new Pt(anchor));\n      g[1].toAngle(angle, magnitude, true);\n      return g;\n    }\n  }, {\n    key: \"slope\",\n    value: function slope(p1, p2) {\n      return p2[0] - p1[0] === 0 ? undefined : (p2[1] - p1[1]) / (p2[0] - p1[0]);\n    }\n  }, {\n    key: \"intercept\",\n    value: function intercept(p1, p2) {\n      if (p2[0] - p1[0] === 0) {\n        return undefined;\n      } else {\n        var m = (p2[1] - p1[1]) / (p2[0] - p1[0]);\n        var c = p1[1] - m * p1[0];\n        return {\n          slope: m,\n          yi: c,\n          xi: m === 0 ? undefined : -c / m\n        };\n      }\n    }\n  }, {\n    key: \"sideOfPt2D\",\n    value: function sideOfPt2D(line, pt) {\n      return (line[1][0] - line[0][0]) * (pt[1] - line[0][1]) - (pt[0] - line[0][0]) * (line[1][1] - line[0][1]);\n    }\n  }, {\n    key: \"collinear\",\n    value: function collinear(p1, p2, p3) {\n      var threshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.01;\n      var a = new Pt(0, 0, 0).to(p1).$subtract(p2);\n      var b = new Pt(0, 0, 0).to(p1).$subtract(p3);\n      return a.$cross(b).divide(1000).equals(new Pt(0, 0, 0), threshold);\n    }\n  }, {\n    key: \"magnitude\",\n    value: function magnitude(line) {\n      return line.length >= 2 ? line[1].$subtract(line[0]).magnitude() : 0;\n    }\n  }, {\n    key: \"magnitudeSq\",\n    value: function magnitudeSq(line) {\n      return line.length >= 2 ? line[1].$subtract(line[0]).magnitudeSq() : 0;\n    }\n  }, {\n    key: \"perpendicularFromPt\",\n    value: function perpendicularFromPt(line, pt) {\n      var asProjection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (line[0].equals(line[1])) return undefined;\n      var a = line[0].$subtract(line[1]);\n      var b = line[1].$subtract(pt);\n      var proj = b.$subtract(a.$project(b));\n      return asProjection ? proj : proj.$add(pt);\n    }\n  }, {\n    key: \"distanceFromPt\",\n    value: function distanceFromPt(line, pt) {\n      return Line.perpendicularFromPt(line, pt, true).magnitude();\n    }\n  }, {\n    key: \"intersectRay2D\",\n    value: function intersectRay2D(la, lb) {\n      var a = Line.intercept(la[0], la[1]);\n      var b = Line.intercept(lb[0], lb[1]);\n      var pa = la[0];\n      var pb = lb[0];\n\n      if (a == undefined) {\n        if (b == undefined) return undefined;\n        var y1 = -b.slope * (pb[0] - pa[0]) + pb[1];\n        return new Pt(pa[0], y1);\n      } else {\n        if (b == undefined) {\n          var _y = -a.slope * (pa[0] - pb[0]) + pa[1];\n\n          return new Pt(pb[0], _y);\n        } else if (b.slope != a.slope) {\n          var px = (a.slope * pa[0] - b.slope * pb[0] + pb[1] - pa[1]) / (a.slope - b.slope);\n          var py = a.slope * (px - pa[0]) + pa[1];\n          return new Pt(px, py);\n        } else {\n          if (a.yi == b.yi) {\n            return new Pt(pa[0], pa[1]);\n          } else {\n            return undefined;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"intersectLine2D\",\n    value: function intersectLine2D(la, lb) {\n      var pt = Line.intersectRay2D(la, lb);\n      return pt && Geom.withinBound(pt, la[0], la[1]) && Geom.withinBound(pt, lb[0], lb[1]) ? pt : undefined;\n    }\n  }, {\n    key: \"intersectLineWithRay2D\",\n    value: function intersectLineWithRay2D(line, ray) {\n      var pt = Line.intersectRay2D(line, ray);\n      return pt && Geom.withinBound(pt, line[0], line[1]) ? pt : undefined;\n    }\n  }, {\n    key: \"intersectPolygon2D\",\n    value: function intersectPolygon2D(lineOrRay, poly) {\n      var sourceIsRay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var fn = sourceIsRay ? Line.intersectLineWithRay2D : Line.intersectLine2D;\n      var pts = new Group();\n\n      for (var i = 0, len = poly.length; i < len; i++) {\n        var next = i === len - 1 ? 0 : i + 1;\n        var d = fn([poly[i], poly[next]], lineOrRay);\n        if (d) pts.push(d);\n      }\n\n      return pts.length > 0 ? pts : undefined;\n    }\n  }, {\n    key: \"intersectLines2D\",\n    value: function intersectLines2D(lines1, lines2) {\n      var isRay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var group = new Group();\n      var fn = isRay ? Line.intersectLineWithRay2D : Line.intersectLine2D;\n\n      for (var i = 0, len = lines1.length; i < len; i++) {\n        for (var k = 0, lenk = lines2.length; k < lenk; k++) {\n          var _ip = fn(lines1[i], lines2[k]);\n\n          if (_ip) group.push(_ip);\n        }\n      }\n\n      return group;\n    }\n  }, {\n    key: \"intersectGridWithRay2D\",\n    value: function intersectGridWithRay2D(ray, gridPt) {\n      var t = Line.intercept(new Pt(ray[0]).subtract(gridPt), new Pt(ray[1]).subtract(gridPt));\n      var g = new Group();\n      if (t && t.xi) g.push(new Pt(gridPt[0] + t.xi, gridPt[1]));\n      if (t && t.yi) g.push(new Pt(gridPt[0], gridPt[1] + t.yi));\n      return g;\n    }\n  }, {\n    key: \"intersectGridWithLine2D\",\n    value: function intersectGridWithLine2D(line, gridPt) {\n      var g = Line.intersectGridWithRay2D(line, gridPt);\n      var gg = new Group();\n\n      for (var i = 0, len = g.length; i < len; i++) {\n        if (Geom.withinBound(g[i], line[0], line[1])) gg.push(g[i]);\n      }\n\n      return gg;\n    }\n  }, {\n    key: \"intersectRect2D\",\n    value: function intersectRect2D(line, rect) {\n      var box = Geom.boundingBox(Group.fromPtArray(line));\n      if (!Rectangle.hasIntersectRect2D(box, rect)) return new Group();\n      return Line.intersectLines2D([line], Rectangle.sides(rect));\n    }\n  }, {\n    key: \"subpoints\",\n    value: function subpoints(line, num) {\n      var pts = new Group();\n\n      for (var i = 1; i <= num; i++) {\n        pts.push(Geom.interpolate(line[0], line[1], i / (num + 1)));\n      }\n\n      return pts;\n    }\n  }, {\n    key: \"crop\",\n    value: function crop(line, size) {\n      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var cropAsCircle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var tdx = index === 0 ? 1 : 0;\n      var ls = line[tdx].$subtract(line[index]);\n      if (ls[0] === 0 || size[0] === 0) return line[index];\n\n      if (cropAsCircle) {\n        var d = ls.unit().multiply(size[1]);\n        return line[index].$add(d);\n      } else {\n        var rect = Rectangle.fromCenter(line[index], size);\n        var sides = Rectangle.sides(rect);\n        var sideIdx = 0;\n\n        if (Math.abs(ls[1] / ls[0]) > Math.abs(size[1] / size[0])) {\n          sideIdx = ls[1] < 0 ? 0 : 2;\n        } else {\n          sideIdx = ls[0] < 0 ? 3 : 1;\n        }\n\n        return Line.intersectRay2D(sides[sideIdx], line);\n      }\n    }\n  }, {\n    key: \"marker\",\n    value: function marker(line, size) {\n      var graphic = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"arrow\" || \"line\";\n      var atTail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var h = atTail ? 0 : 1;\n      var t = atTail ? 1 : 0;\n      var unit = line[h].$subtract(line[t]);\n      if (unit.magnitudeSq() === 0) return new Group();\n      unit.unit();\n      var ps = Geom.perpendicular(unit).multiply(size[0]).add(line[t]);\n\n      if (graphic == \"arrow\") {\n        ps.add(unit.$multiply(size[1]));\n        return new Group(line[t], ps[0], ps[1]);\n      } else {\n        return new Group(ps[0], ps[1]);\n      }\n    }\n  }, {\n    key: \"toRect\",\n    value: function toRect(line) {\n      return new Group(line[0].$min(line[1]), line[0].$max(line[1]));\n    }\n  }]);\n\n  return Line;\n}();\nexport var Rectangle =\n/*#__PURE__*/\nfunction () {\n  function Rectangle() {\n    _classCallCheck(this, Rectangle);\n  }\n\n  _createClass(Rectangle, null, [{\n    key: \"from\",\n    value: function from(topLeft, widthOrSize, height) {\n      return Rectangle.fromTopLeft(topLeft, widthOrSize, height);\n    }\n  }, {\n    key: \"fromTopLeft\",\n    value: function fromTopLeft(topLeft, widthOrSize, height) {\n      var size = typeof widthOrSize == \"number\" ? [widthOrSize, height || widthOrSize] : widthOrSize;\n      return new Group(new Pt(topLeft), new Pt(topLeft).add(size));\n    }\n  }, {\n    key: \"fromCenter\",\n    value: function fromCenter(center, widthOrSize, height) {\n      var half = typeof widthOrSize == \"number\" ? [widthOrSize / 2, (height || widthOrSize) / 2] : new Pt(widthOrSize).divide(2);\n      return new Group(new Pt(center).subtract(half), new Pt(center).add(half));\n    }\n  }, {\n    key: \"toCircle\",\n    value: function toCircle(pts) {\n      var within = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return Circle.fromRect(pts, within);\n    }\n  }, {\n    key: \"toSquare\",\n    value: function toSquare(pts) {\n      var enclose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var s = Rectangle.size(pts);\n      var m = enclose ? s.maxValue().value : s.minValue().value;\n      return Rectangle.fromCenter(Rectangle.center(pts), m, m);\n    }\n  }, {\n    key: \"size\",\n    value: function size(pts) {\n      return pts[0].$max(pts[1]).subtract(pts[0].$min(pts[1]));\n    }\n  }, {\n    key: \"center\",\n    value: function center(pts) {\n      var min = pts[0].$min(pts[1]);\n      var max = pts[0].$max(pts[1]);\n      return min.add(max.$subtract(min).divide(2));\n    }\n  }, {\n    key: \"corners\",\n    value: function corners(rect) {\n      var p0 = rect[0].$min(rect[1]);\n      var p2 = rect[0].$max(rect[1]);\n      return new Group(p0, new Pt(p2.x, p0.y), p2, new Pt(p0.x, p2.y));\n    }\n  }, {\n    key: \"sides\",\n    value: function sides(rect) {\n      var _Rectangle$corners = Rectangle.corners(rect),\n          _Rectangle$corners2 = _slicedToArray(_Rectangle$corners, 4),\n          p0 = _Rectangle$corners2[0],\n          p1 = _Rectangle$corners2[1],\n          p2 = _Rectangle$corners2[2],\n          p3 = _Rectangle$corners2[3];\n\n      return [new Group(p0, p1), new Group(p1, p2), new Group(p2, p3), new Group(p3, p0)];\n    }\n  }, {\n    key: \"boundingBox\",\n    value: function boundingBox(rects) {\n      var merged = Util.flatten(rects, false);\n      var min = Pt.make(2, Number.MAX_VALUE);\n      var max = Pt.make(2, Number.MIN_VALUE);\n\n      for (var i = 0, len = merged.length; i < len; i++) {\n        for (var k = 0; k < 2; k++) {\n          min[k] = Math.min(min[k], merged[i][k]);\n          max[k] = Math.max(max[k], merged[i][k]);\n        }\n      }\n\n      return new Group(min, max);\n    }\n  }, {\n    key: \"polygon\",\n    value: function polygon(rect) {\n      return Rectangle.corners(rect);\n    }\n  }, {\n    key: \"quadrants\",\n    value: function quadrants(rect, center) {\n      var corners = Rectangle.corners(rect);\n\n      var _center = center != undefined ? new Pt(center) : Rectangle.center(rect);\n\n      return corners.map(function (c) {\n        return new Group(c, _center).boundingBox();\n      });\n    }\n  }, {\n    key: \"halves\",\n    value: function halves(rect) {\n      var ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;\n      var asRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var min = rect[0].$min(rect[1]);\n      var max = rect[0].$max(rect[1]);\n      var mid = asRows ? Num.lerp(min[1], max[1], ratio) : Num.lerp(min[0], max[0], ratio);\n      return asRows ? [new Group(min, new Pt(max[0], mid)), new Group(new Pt(min[0], mid), max)] : [new Group(min, new Pt(mid, max[1])), new Group(new Pt(mid, min[1]), max)];\n    }\n  }, {\n    key: \"withinBound\",\n    value: function withinBound(rect, pt) {\n      return Geom.withinBound(pt, rect[0], rect[1]);\n    }\n  }, {\n    key: \"hasIntersectRect2D\",\n    value: function hasIntersectRect2D(rect1, rect2) {\n      var resetBoundingBox = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (resetBoundingBox) {\n        rect1 = Geom.boundingBox(rect1);\n        rect2 = Geom.boundingBox(rect2);\n      }\n\n      if (rect1[0][0] > rect2[1][0] || rect2[0][0] > rect1[1][0]) return false;\n      if (rect1[0][1] > rect2[1][1] || rect2[0][1] > rect1[1][1]) return false;\n      return true;\n    }\n  }, {\n    key: \"intersectRect2D\",\n    value: function intersectRect2D(rect1, rect2) {\n      if (!Rectangle.hasIntersectRect2D(rect1, rect2)) return new Group();\n      return Line.intersectLines2D(Rectangle.sides(rect1), Rectangle.sides(rect2));\n    }\n  }]);\n\n  return Rectangle;\n}();\nexport var Circle =\n/*#__PURE__*/\nfunction () {\n  function Circle() {\n    _classCallCheck(this, Circle);\n  }\n\n  _createClass(Circle, null, [{\n    key: \"fromRect\",\n    value: function fromRect(pts) {\n      var enclose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var r = 0;\n      var min = r = Rectangle.size(pts).minValue().value / 2;\n\n      if (enclose) {\n        var max = Rectangle.size(pts).maxValue().value / 2;\n        r = Math.sqrt(min * min + max * max);\n      } else {\n        r = min;\n      }\n\n      return new Group(Rectangle.center(pts), new Pt(r, r));\n    }\n  }, {\n    key: \"fromTriangle\",\n    value: function fromTriangle(pts) {\n      var enclose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (enclose) {\n        return Triangle.circumcircle(pts);\n      } else {\n        return Triangle.incircle(pts);\n      }\n    }\n  }, {\n    key: \"fromCenter\",\n    value: function fromCenter(pt, radius) {\n      return new Group(new Pt(pt), new Pt(radius, radius));\n    }\n  }, {\n    key: \"withinBound\",\n    value: function withinBound(pts, pt) {\n      var threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var d = pts[0].$subtract(pt);\n      return d.dot(d) + threshold < pts[1].x * pts[1].x;\n    }\n  }, {\n    key: \"intersectRay2D\",\n    value: function intersectRay2D(pts, ray) {\n      var d = ray[0].$subtract(ray[1]);\n      var f = pts[0].$subtract(ray[0]);\n      var a = d.dot(d);\n      var b = f.dot(d);\n      var c = f.dot(f) - pts[1].x * pts[1].x;\n      var p = b / a;\n      var q = c / a;\n      var disc = p * p - q;\n\n      if (disc < 0) {\n        return new Group();\n      } else {\n        var discSqrt = Math.sqrt(disc);\n        var t1 = -p + discSqrt;\n        var p1 = ray[0].$subtract(d.$multiply(t1));\n        if (disc === 0) return new Group(p1);\n        var t2 = -p - discSqrt;\n        var p2 = ray[0].$subtract(d.$multiply(t2));\n        return new Group(p1, p2);\n      }\n    }\n  }, {\n    key: \"intersectLine2D\",\n    value: function intersectLine2D(pts, line) {\n      var ps = Circle.intersectRay2D(pts, line);\n      var g = new Group();\n\n      if (ps.length > 0) {\n        for (var i = 0, len = ps.length; i < len; i++) {\n          if (Rectangle.withinBound(line, ps[i])) g.push(ps[i]);\n        }\n      }\n\n      return g;\n    }\n  }, {\n    key: \"intersectCircle2D\",\n    value: function intersectCircle2D(pts, circle) {\n      var dv = circle[0].$subtract(pts[0]);\n      var dr2 = dv.magnitudeSq();\n      var dr = Math.sqrt(dr2);\n      var ar = pts[1].x;\n      var br = circle[1].x;\n      var ar2 = ar * ar;\n      var br2 = br * br;\n\n      if (dr > ar + br) {\n        return new Group();\n      } else if (dr < Math.abs(ar - br)) {\n        return new Group(pts[0].clone());\n      } else {\n        var a = (ar2 - br2 + dr2) / (2 * dr);\n        var h = Math.sqrt(ar2 - a * a);\n        var p = dv.$multiply(a / dr).add(pts[0]);\n        return new Group(new Pt(p.x + h * dv.y / dr, p.y - h * dv.x / dr), new Pt(p.x - h * dv.y / dr, p.y + h * dv.x / dr));\n      }\n    }\n  }, {\n    key: \"intersectRect2D\",\n    value: function intersectRect2D(pts, rect) {\n      var sides = Rectangle.sides(rect);\n      var g = [];\n\n      for (var i = 0, len = sides.length; i < len; i++) {\n        var ps = Circle.intersectLine2D(pts, sides[i]);\n        if (ps.length > 0) g.push(ps);\n      }\n\n      return Util.flatten(g);\n    }\n  }, {\n    key: \"toRect\",\n    value: function toRect(pts) {\n      var within = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var r = pts[1][0];\n\n      if (within) {\n        var half = Math.sqrt(r * r) / 2;\n        return new Group(pts[0].$subtract(half), pts[0].$add(half));\n      } else {\n        return new Group(pts[0].$subtract(r), pts[0].$add(r));\n      }\n    }\n  }, {\n    key: \"toTriangle\",\n    value: function toTriangle(pts) {\n      var within = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (within) {\n        var ang = -Math.PI / 2;\n        var inc = Math.PI * 2 / 3;\n        var g = new Group();\n\n        for (var i = 0; i < 3; i++) {\n          g.push(pts[0].clone().toAngle(ang, pts[1][0], true));\n          ang += inc;\n        }\n\n        return g;\n      } else {\n        return Triangle.fromCenter(pts[0], pts[1][0]);\n      }\n    }\n  }]);\n\n  return Circle;\n}();\nexport var Triangle =\n/*#__PURE__*/\nfunction () {\n  function Triangle() {\n    _classCallCheck(this, Triangle);\n  }\n\n  _createClass(Triangle, null, [{\n    key: \"fromRect\",\n    value: function fromRect(rect) {\n      var top = rect[0].$add(rect[1]).divide(2);\n      top.y = rect[0][1];\n      var left = rect[1].clone();\n      left.x = rect[0][0];\n      return new Group(top, rect[1].clone(), left);\n    }\n  }, {\n    key: \"fromCircle\",\n    value: function fromCircle(circle) {\n      return Circle.toTriangle(circle, true);\n    }\n  }, {\n    key: \"fromCenter\",\n    value: function fromCenter(pt, size) {\n      return Triangle.fromCircle(Circle.fromCenter(pt, size));\n    }\n  }, {\n    key: \"medial\",\n    value: function medial(pts) {\n      if (pts.length < 3) return _errorLength(new Group(), 3);\n      return Polygon.midpoints(pts, true);\n    }\n  }, {\n    key: \"oppositeSide\",\n    value: function oppositeSide(pts, index) {\n      if (pts.length < 3) return _errorLength(new Group(), 3);\n\n      if (index === 0) {\n        return Group.fromPtArray([pts[1], pts[2]]);\n      } else if (index === 1) {\n        return Group.fromPtArray([pts[0], pts[2]]);\n      } else {\n        return Group.fromPtArray([pts[0], pts[1]]);\n      }\n    }\n  }, {\n    key: \"altitude\",\n    value: function altitude(pts, index) {\n      var opp = Triangle.oppositeSide(pts, index);\n\n      if (opp.length > 1) {\n        return new Group(pts[index], Line.perpendicularFromPt(opp, pts[index]));\n      } else {\n        return new Group();\n      }\n    }\n  }, {\n    key: \"orthocenter\",\n    value: function orthocenter(pts) {\n      if (pts.length < 3) return _errorLength(undefined, 3);\n      var a = Triangle.altitude(pts, 0);\n      var b = Triangle.altitude(pts, 1);\n      return Line.intersectRay2D(a, b);\n    }\n  }, {\n    key: \"incenter\",\n    value: function incenter(pts) {\n      if (pts.length < 3) return _errorLength(undefined, 3);\n      var a = Polygon.bisector(pts, 0).add(pts[0]);\n      var b = Polygon.bisector(pts, 1).add(pts[1]);\n      return Line.intersectRay2D(new Group(pts[0], a), new Group(pts[1], b));\n    }\n  }, {\n    key: \"incircle\",\n    value: function incircle(pts, center) {\n      var c = center ? center : Triangle.incenter(pts);\n      var area = Polygon.area(pts);\n      var perim = Polygon.perimeter(pts, true);\n      var r = 2 * area / perim.total;\n      return Circle.fromCenter(c, r);\n    }\n  }, {\n    key: \"circumcenter\",\n    value: function circumcenter(pts) {\n      var md = Triangle.medial(pts);\n      var a = [md[0], Geom.perpendicular(pts[0].$subtract(md[0])).p1.$add(md[0])];\n      var b = [md[1], Geom.perpendicular(pts[1].$subtract(md[1])).p1.$add(md[1])];\n      return Line.intersectRay2D(a, b);\n    }\n  }, {\n    key: \"circumcircle\",\n    value: function circumcircle(pts, center) {\n      var c = center ? center : Triangle.circumcenter(pts);\n      var r = pts[0].$subtract(c).magnitude();\n      return Circle.fromCenter(c, r);\n    }\n  }]);\n\n  return Triangle;\n}();\nexport var Polygon =\n/*#__PURE__*/\nfunction () {\n  function Polygon() {\n    _classCallCheck(this, Polygon);\n  }\n\n  _createClass(Polygon, null, [{\n    key: \"centroid\",\n    value: function centroid(pts) {\n      return Geom.centroid(pts);\n    }\n  }, {\n    key: \"rectangle\",\n    value: function rectangle(center, widthOrSize, height) {\n      return Rectangle.corners(Rectangle.fromCenter(center, widthOrSize, height));\n    }\n  }, {\n    key: \"fromCenter\",\n    value: function fromCenter(center, radius, sides) {\n      var g = new Group();\n\n      for (var i = 0; i < sides; i++) {\n        var ang = Math.PI * 2 * i / sides;\n        g.push(new Pt(Math.cos(ang) * radius, Math.sin(ang) * radius).add(center));\n      }\n\n      return g;\n    }\n  }, {\n    key: \"lineAt\",\n    value: function lineAt(pts, idx) {\n      if (idx < 0 || idx >= pts.length) throw new Error(\"index out of the Polygon's range\");\n      return new Group(pts[idx], idx === pts.length - 1 ? pts[0] : pts[idx + 1]);\n    }\n  }, {\n    key: \"lines\",\n    value: function lines(pts) {\n      var closePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (pts.length < 2) return _errorLength(new Group(), 2);\n      var sp = Util.split(pts, 2, 1);\n      if (closePath) sp.push(new Group(pts[pts.length - 1], pts[0]));\n      return sp.map(function (g) {\n        return g;\n      });\n    }\n  }, {\n    key: \"midpoints\",\n    value: function midpoints(pts) {\n      var closePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;\n      if (pts.length < 2) return _errorLength(new Group(), 2);\n      var sides = Polygon.lines(pts, closePath);\n      var mids = sides.map(function (s) {\n        return Geom.interpolate(s[0], s[1], t);\n      });\n      return mids;\n    }\n  }, {\n    key: \"adjacentSides\",\n    value: function adjacentSides(pts, index) {\n      var closePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (pts.length < 2) return _errorLength(new Group(), 2);\n      if (index < 0 || index >= pts.length) return _errorOutofBound(new Group(), index);\n      var gs = [];\n      var left = index - 1;\n      if (closePath && left < 0) left = pts.length - 1;\n      if (left >= 0) gs.push(new Group(pts[index], pts[left]));\n      var right = index + 1;\n      if (closePath && right > pts.length - 1) right = 0;\n      if (right <= pts.length - 1) gs.push(new Group(pts[index], pts[right]));\n      return gs;\n    }\n  }, {\n    key: \"bisector\",\n    value: function bisector(pts, index) {\n      var sides = Polygon.adjacentSides(pts, index, true);\n\n      if (sides.length >= 2) {\n        var a = sides[0][1].$subtract(sides[0][0]).unit();\n        var b = sides[1][1].$subtract(sides[1][0]).unit();\n        return a.add(b).divide(2);\n      } else {\n        return undefined;\n      }\n    }\n  }, {\n    key: \"perimeter\",\n    value: function perimeter(pts) {\n      var closePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (pts.length < 2) return _errorLength(new Group(), 2);\n      var lines = Polygon.lines(pts, closePath);\n      var mag = 0;\n      var p = Pt.make(lines.length, 0);\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        var m = Line.magnitude(lines[i]);\n        mag += m;\n        p[i] = m;\n      }\n\n      return {\n        total: mag,\n        segments: p\n      };\n    }\n  }, {\n    key: \"area\",\n    value: function area(pts) {\n      if (pts.length < 3) return _errorLength(new Group(), 3);\n\n      var det = function det(a, b) {\n        return a[0] * b[1] - a[1] * b[0];\n      };\n\n      var area = 0;\n\n      for (var i = 0, len = pts.length; i < len; i++) {\n        if (i < pts.length - 1) {\n          area += det(pts[i], pts[i + 1]);\n        } else {\n          area += det(pts[i], pts[0]);\n        }\n      }\n\n      return Math.abs(area / 2);\n    }\n  }, {\n    key: \"convexHull\",\n    value: function convexHull(pts) {\n      var sorted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (pts.length < 3) return _errorLength(new Group(), 3);\n\n      if (!sorted) {\n        pts = pts.slice();\n        pts.sort(function (a, b) {\n          return a[0] - b[0];\n        });\n      }\n\n      var left = function left(a, b, c) {\n        return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]) > 0;\n      };\n\n      var dq = [];\n      var bot = pts.length - 2;\n      var top = bot + 3;\n      dq[bot] = pts[2];\n      dq[top] = pts[2];\n\n      if (left(pts[0], pts[1], pts[2])) {\n        dq[bot + 1] = pts[0];\n        dq[bot + 2] = pts[1];\n      } else {\n        dq[bot + 1] = pts[1];\n        dq[bot + 2] = pts[0];\n      }\n\n      for (var i = 3, len = pts.length; i < len; i++) {\n        var pt = pts[i];\n\n        if (left(dq[bot], dq[bot + 1], pt) && left(dq[top - 1], dq[top], pt)) {\n          continue;\n        }\n\n        while (!left(dq[bot], dq[bot + 1], pt)) {\n          bot += 1;\n        }\n\n        bot -= 1;\n        dq[bot] = pt;\n\n        while (!left(dq[top - 1], dq[top], pt)) {\n          top -= 1;\n        }\n\n        top += 1;\n        dq[top] = pt;\n      }\n\n      var hull = new Group();\n\n      for (var h = 0; h < top - bot; h++) {\n        hull.push(dq[bot + h]);\n      }\n\n      return hull;\n    }\n  }, {\n    key: \"network\",\n    value: function network(pts) {\n      var originIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var g = [];\n\n      for (var i = 0, len = pts.length; i < len; i++) {\n        if (i != originIndex) g.push(new Group(pts[originIndex], pts[i]));\n      }\n\n      return g;\n    }\n  }, {\n    key: \"nearestPt\",\n    value: function nearestPt(pts, pt) {\n      var _near = Number.MAX_VALUE;\n\n      var _item = -1;\n\n      for (var i = 0, len = pts.length; i < len; i++) {\n        var d = pts[i].$subtract(pt).magnitudeSq();\n\n        if (d < _near) {\n          _near = d;\n          _item = i;\n        }\n      }\n\n      return _item;\n    }\n  }, {\n    key: \"projectAxis\",\n    value: function projectAxis(poly, unitAxis) {\n      var dot = unitAxis.dot(poly[0]);\n      var d = new Pt(dot, dot);\n\n      for (var n = 1, len = poly.length; n < len; n++) {\n        dot = unitAxis.dot(poly[n]);\n        d = new Pt(Math.min(dot, d[0]), Math.max(dot, d[1]));\n      }\n\n      return d;\n    }\n  }, {\n    key: \"_axisOverlap\",\n    value: function _axisOverlap(poly1, poly2, unitAxis) {\n      var pa = Polygon.projectAxis(poly1, unitAxis);\n      var pb = Polygon.projectAxis(poly2, unitAxis);\n      return pa[0] < pb[0] ? pb[0] - pa[1] : pa[0] - pb[1];\n    }\n  }, {\n    key: \"hasIntersectPoint\",\n    value: function hasIntersectPoint(poly, pt) {\n      var c = false;\n\n      for (var i = 0, len = poly.length; i < len; i++) {\n        var ln = Polygon.lineAt(poly, i);\n\n        if (ln[0][1] > pt[1] != ln[1][1] > pt[1] && pt[0] < (ln[1][0] - ln[0][0]) * (pt[1] - ln[0][1]) / (ln[1][1] - ln[0][1]) + ln[0][0]) {\n          c = !c;\n        }\n      }\n\n      return c;\n    }\n  }, {\n    key: \"hasIntersectCircle\",\n    value: function hasIntersectCircle(poly, circle) {\n      var info = {\n        which: -1,\n        dist: 0,\n        normal: null,\n        edge: null,\n        vertex: null\n      };\n      var c = circle[0];\n      var r = circle[1][0];\n      var minDist = Number.MAX_SAFE_INTEGER;\n\n      for (var i = 0, len = poly.length; i < len; i++) {\n        var edge = Polygon.lineAt(poly, i);\n        var axis = new Pt(edge[0].y - edge[1].y, edge[1].x - edge[0].x).unit();\n        var poly2 = new Group(c.$add(axis.$multiply(r)), c.$subtract(axis.$multiply(r)));\n\n        var dist = Polygon._axisOverlap(poly, poly2, axis);\n\n        if (dist > 0) {\n          return null;\n        } else if (Math.abs(dist) < minDist) {\n          var check = Rectangle.withinBound(edge, Line.perpendicularFromPt(edge, c)) || Circle.intersectLine2D(circle, edge).length > 0;\n\n          if (check) {\n            info.edge = edge;\n            info.normal = axis;\n            minDist = Math.abs(dist);\n            info.which = i;\n          }\n        }\n      }\n\n      if (!info.edge) return null;\n      var dir = c.$subtract(Polygon.centroid(poly)).dot(info.normal);\n      if (dir < 0) info.normal.multiply(-1);\n      info.dist = minDist;\n      info.vertex = c;\n      return info;\n    }\n  }, {\n    key: \"hasIntersectPolygon\",\n    value: function hasIntersectPolygon(poly1, poly2) {\n      var info = {\n        which: -1,\n        dist: 0,\n        normal: new Pt(),\n        edge: new Group(),\n        vertex: new Pt()\n      };\n      var minDist = Number.MAX_SAFE_INTEGER;\n\n      for (var i = 0, plen = poly1.length + poly2.length; i < plen; i++) {\n        var edge = i < poly1.length ? Polygon.lineAt(poly1, i) : Polygon.lineAt(poly2, i - poly1.length);\n        var axis = new Pt(edge[0].y - edge[1].y, edge[1].x - edge[0].x).unit();\n\n        var dist = Polygon._axisOverlap(poly1, poly2, axis);\n\n        if (dist > 0) {\n          return null;\n        } else if (Math.abs(dist) < minDist) {\n          info.edge = edge;\n          info.normal = axis;\n          minDist = Math.abs(dist);\n          info.which = i < poly1.length ? 0 : 1;\n        }\n      }\n\n      info.dist = minDist;\n      var b1 = info.which === 0 ? poly2 : poly1;\n      var b2 = info.which === 0 ? poly1 : poly2;\n      var c1 = Polygon.centroid(b1);\n      var c2 = Polygon.centroid(b2);\n      var dir = c1.$subtract(c2).dot(info.normal);\n      if (dir < 0) info.normal.multiply(-1);\n      var smallest = Number.MAX_SAFE_INTEGER;\n\n      for (var _i = 0, len = b1.length; _i < len; _i++) {\n        var d = info.normal.dot(b1[_i].$subtract(c2));\n\n        if (d < smallest) {\n          smallest = d;\n          info.vertex = b1[_i];\n        }\n      }\n\n      return info;\n    }\n  }, {\n    key: \"intersectPolygon2D\",\n    value: function intersectPolygon2D(poly1, poly2) {\n      var lp = Polygon.lines(poly1);\n      var g = [];\n\n      for (var i = 0, len = lp.length; i < len; i++) {\n        var ins = Line.intersectPolygon2D(lp[i], poly2, false);\n        if (ins) g.push(ins);\n      }\n\n      return Util.flatten(g, true);\n    }\n  }, {\n    key: \"toRects\",\n    value: function toRects(polys) {\n      var boxes = polys.map(function (g) {\n        return Geom.boundingBox(g);\n      });\n      var merged = Util.flatten(boxes, false);\n      boxes.unshift(Geom.boundingBox(merged));\n      return boxes;\n    }\n  }]);\n\n  return Polygon;\n}();\nexport var Curve =\n/*#__PURE__*/\nfunction () {\n  function Curve() {\n    _classCallCheck(this, Curve);\n  }\n\n  _createClass(Curve, null, [{\n    key: \"getSteps\",\n    value: function getSteps(steps) {\n      var ts = new Group();\n\n      for (var i = 0; i <= steps; i++) {\n        var t = i / steps;\n        ts.push(new Pt(t * t * t, t * t, t, 1));\n      }\n\n      return ts;\n    }\n  }, {\n    key: \"controlPoints\",\n    value: function controlPoints(pts) {\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var copyStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (index > pts.length - 1) return new Group();\n\n      var _index = function _index(i) {\n        return i < pts.length - 1 ? i : pts.length - 1;\n      };\n\n      var p0 = pts[index];\n      index = copyStart ? index : index + 1;\n      return new Group(p0, pts[_index(index++)], pts[_index(index++)], pts[_index(index++)]);\n    }\n  }, {\n    key: \"_calcPt\",\n    value: function _calcPt(ctrls, params) {\n      var x = ctrls.reduce(function (a, c, i) {\n        return a + c.x * params[i];\n      }, 0);\n      var y = ctrls.reduce(function (a, c, i) {\n        return a + c.y * params[i];\n      }, 0);\n\n      if (ctrls[0].length > 2) {\n        var z = ctrls.reduce(function (a, c, i) {\n          return a + c.z * params[i];\n        }, 0);\n        return new Pt(x, y, z);\n      }\n\n      return new Pt(x, y);\n    }\n  }, {\n    key: \"catmullRom\",\n    value: function catmullRom(pts) {\n      var steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n      if (pts.length < 2) return new Group();\n      var ps = new Group();\n      var ts = Curve.getSteps(steps);\n      var c = Curve.controlPoints(pts, 0, true);\n\n      for (var i = 0; i <= steps; i++) {\n        ps.push(Curve.catmullRomStep(ts[i], c));\n      }\n\n      var k = 0;\n\n      while (k < pts.length - 2) {\n        var cp = Curve.controlPoints(pts, k);\n\n        if (cp.length > 0) {\n          for (var _i2 = 0; _i2 <= steps; _i2++) {\n            ps.push(Curve.catmullRomStep(ts[_i2], cp));\n          }\n\n          k++;\n        }\n      }\n\n      return ps;\n    }\n  }, {\n    key: \"catmullRomStep\",\n    value: function catmullRomStep(step, ctrls) {\n      var m = new Group(new Pt(-0.5, 1, -0.5, 0), new Pt(1.5, -2.5, 0, 1), new Pt(-1.5, 2, 0.5, 0), new Pt(0.5, -0.5, 0, 0));\n      return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n    }\n  }, {\n    key: \"cardinal\",\n    value: function cardinal(pts) {\n      var steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n      var tension = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;\n      if (pts.length < 2) return new Group();\n      var ps = new Group();\n      var ts = Curve.getSteps(steps);\n      var c = Curve.controlPoints(pts, 0, true);\n\n      for (var i = 0; i <= steps; i++) {\n        ps.push(Curve.cardinalStep(ts[i], c, tension));\n      }\n\n      var k = 0;\n\n      while (k < pts.length - 2) {\n        var cp = Curve.controlPoints(pts, k);\n\n        if (cp.length > 0) {\n          for (var _i3 = 0; _i3 <= steps; _i3++) {\n            ps.push(Curve.cardinalStep(ts[_i3], cp, tension));\n          }\n\n          k++;\n        }\n      }\n\n      return ps;\n    }\n  }, {\n    key: \"cardinalStep\",\n    value: function cardinalStep(step, ctrls) {\n      var tension = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;\n      var m = new Group(new Pt(-1, 2, -1, 0), new Pt(-1, 1, 0, 0), new Pt(1, -2, 1, 0), new Pt(1, -1, 0, 0));\n      var h = Mat.multiply([step], m, true)[0].multiply(tension);\n      var h2 = 2 * step[0] - 3 * step[1] + 1;\n      var h3 = -2 * step[0] + 3 * step[1];\n\n      var pt = Curve._calcPt(ctrls, h);\n\n      pt.x += h2 * ctrls[1].x + h3 * ctrls[2].x;\n      pt.y += h2 * ctrls[1].y + h3 * ctrls[2].y;\n      if (pt.length > 2) pt.z += h2 * ctrls[1].z + h3 * ctrls[2].z;\n      return pt;\n    }\n  }, {\n    key: \"bezier\",\n    value: function bezier(pts) {\n      var steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n      if (pts.length < 4) return new Group();\n      var ps = new Group();\n      var ts = Curve.getSteps(steps);\n      var k = 0;\n\n      while (k < pts.length - 3) {\n        var c = Curve.controlPoints(pts, k);\n\n        if (c.length > 0) {\n          for (var i = 0; i <= steps; i++) {\n            ps.push(Curve.bezierStep(ts[i], c));\n          }\n\n          k += 3;\n        }\n      }\n\n      return ps;\n    }\n  }, {\n    key: \"bezierStep\",\n    value: function bezierStep(step, ctrls) {\n      var m = new Group(new Pt(-1, 3, -3, 1), new Pt(3, -6, 3, 0), new Pt(-3, 3, 0, 0), new Pt(1, 0, 0, 0));\n      return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n    }\n  }, {\n    key: \"bspline\",\n    value: function bspline(pts) {\n      var steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n      var tension = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      if (pts.length < 2) return new Group();\n      var ps = new Group();\n      var ts = Curve.getSteps(steps);\n      var k = 0;\n\n      while (k < pts.length - 3) {\n        var c = Curve.controlPoints(pts, k);\n\n        if (c.length > 0) {\n          if (tension !== 1) {\n            for (var i = 0; i <= steps; i++) {\n              ps.push(Curve.bsplineTensionStep(ts[i], c, tension));\n            }\n          } else {\n            for (var _i4 = 0; _i4 <= steps; _i4++) {\n              ps.push(Curve.bsplineStep(ts[_i4], c));\n            }\n          }\n\n          k++;\n        }\n      }\n\n      return ps;\n    }\n  }, {\n    key: \"bsplineStep\",\n    value: function bsplineStep(step, ctrls) {\n      var m = new Group(new Pt(-0.16666666666666666, 0.5, -0.5, 0.16666666666666666), new Pt(0.5, -1, 0, 0.6666666666666666), new Pt(-0.5, 0.5, 0.5, 0.16666666666666666), new Pt(0.16666666666666666, 0, 0, 0));\n      return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n    }\n  }, {\n    key: \"bsplineTensionStep\",\n    value: function bsplineTensionStep(step, ctrls) {\n      var tension = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var m = new Group(new Pt(-0.16666666666666666, 0.5, -0.5, 0.16666666666666666), new Pt(-1.5, 2, 0, -0.3333333333333333), new Pt(1.5, -2.5, 0.5, 0.16666666666666666), new Pt(0.16666666666666666, 0, 0, 0));\n      var h = Mat.multiply([step], m, true)[0].multiply(tension);\n      var h2 = 2 * step[0] - 3 * step[1] + 1;\n      var h3 = -2 * step[0] + 3 * step[1];\n\n      var pt = Curve._calcPt(ctrls, h);\n\n      pt.x += h2 * ctrls[1].x + h3 * ctrls[2].x;\n      pt.y += h2 * ctrls[1].y + h3 * ctrls[2].y;\n      if (pt.length > 2) pt.z += h2 * ctrls[1].z + h3 * ctrls[2].z;\n      return pt;\n    }\n  }]);\n\n  return Curve;\n}();","map":null,"metadata":{},"sourceType":"module"}