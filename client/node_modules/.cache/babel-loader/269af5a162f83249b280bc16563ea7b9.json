{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/*! Source code licensed under Apache License 2.0. Copyright Â© 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Pt, Group } from \"./Pt\";\nimport { Util } from \"./Util\";\nimport { Num, Geom } from \"./Num\";\nexport var Color =\n/*#__PURE__*/\nfunction (_Pt) {\n  _inherits(Color, _Pt);\n\n  function Color() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, Color);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Color)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this._mode = \"rgb\";\n    _this._isNorm = false;\n    return _this;\n  }\n\n  _createClass(Color, [{\n    key: \"clone\",\n    value: function clone() {\n      var c = new Color(this);\n      c.toMode(this._mode);\n      return c;\n    }\n  }, {\n    key: \"toMode\",\n    value: function toMode(mode) {\n      var convert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (convert) {\n        var fname = this._mode.toUpperCase() + \"to\" + mode.toUpperCase();\n\n        if (Color[fname]) {\n          this.to(Color[fname](this, this._isNorm, this._isNorm));\n        } else {\n          throw new Error(\"Cannot convert color with \" + fname);\n        }\n      }\n\n      this._mode = mode;\n      return this;\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var toNorm = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (this._isNorm == toNorm) return this;\n      var ranges = Color.ranges[this._mode];\n\n      for (var i = 0; i < 3; i++) {\n        this[i] = !toNorm ? Num.mapToRange(this[i], 0, 1, ranges[i][0], ranges[i][1]) : Num.mapToRange(this[i], ranges[i][0], ranges[i][1], 0, 1);\n      }\n\n      this._isNorm = toNorm;\n      return this;\n    }\n  }, {\n    key: \"$normalize\",\n    value: function $normalize() {\n      var toNorm = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return this.clone().normalize(toNorm);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"mode\";\n\n      if (format == \"hex\") {\n        var _hex = function _hex(n) {\n          var s = Math.floor(n).toString(16);\n          return s.length < 2 ? '0' + s : s;\n        };\n\n        return \"#\".concat(_hex(this[0])).concat(_hex(this[1])).concat(_hex(this[2]));\n      } else if (format == \"rgba\") {\n        return \"rgba(\".concat(Math.floor(this[0]), \",\").concat(Math.floor(this[1]), \",\").concat(Math.floor(this[2]), \",\").concat(this.alpha);\n      } else if (format == \"rgb\") {\n        return \"rgb(\".concat(Math.floor(this[0]), \",\").concat(Math.floor(this[1]), \",\").concat(Math.floor(this[2]));\n      } else {\n        return \"\".concat(this._mode, \"(\").concat(this[0], \",\").concat(this[1], \",\").concat(this[2], \",\").concat(this.alpha, \")\");\n      }\n    }\n  }, {\n    key: \"hex\",\n    get: function get() {\n      return this.toString(\"hex\");\n    }\n  }, {\n    key: \"rgb\",\n    get: function get() {\n      return this.toString(\"rgb\");\n    }\n  }, {\n    key: \"rgba\",\n    get: function get() {\n      return this.toString(\"rgba\");\n    }\n  }, {\n    key: \"mode\",\n    get: function get() {\n      return this._mode;\n    }\n  }, {\n    key: \"r\",\n    get: function get() {\n      return this[0];\n    },\n    set: function set(n) {\n      this[0] = n;\n    }\n  }, {\n    key: \"g\",\n    get: function get() {\n      return this[1];\n    },\n    set: function set(n) {\n      this[1] = n;\n    }\n  }, {\n    key: \"b\",\n    get: function get() {\n      return this[2];\n    },\n    set: function set(n) {\n      this[2] = n;\n    }\n  }, {\n    key: \"h\",\n    get: function get() {\n      return this._mode == \"lch\" ? this[2] : this[0];\n    },\n    set: function set(n) {\n      var i = this._mode == \"lch\" ? 2 : 0;\n      this[i] = n;\n    }\n  }, {\n    key: \"s\",\n    get: function get() {\n      return this[1];\n    },\n    set: function set(n) {\n      this[1] = n;\n    }\n  }, {\n    key: \"l\",\n    get: function get() {\n      return this._mode == \"hsl\" ? this[2] : this[0];\n    },\n    set: function set(n) {\n      var i = this._mode == \"hsl\" ? 2 : 0;\n      this[i] = n;\n    }\n  }, {\n    key: \"a\",\n    get: function get() {\n      return this[1];\n    },\n    set: function set(n) {\n      this[1] = n;\n    }\n  }, {\n    key: \"c\",\n    get: function get() {\n      return this[1];\n    },\n    set: function set(n) {\n      this[1] = n;\n    }\n  }, {\n    key: \"u\",\n    get: function get() {\n      return this[1];\n    },\n    set: function set(n) {\n      this[1] = n;\n    }\n  }, {\n    key: \"v\",\n    get: function get() {\n      return this[2];\n    },\n    set: function set(n) {\n      this[2] = n;\n    }\n  }, {\n    key: \"alpha\",\n    get: function get() {\n      return this.length > 3 ? this[3] : 1;\n    }\n  }, {\n    key: \"normalized\",\n    get: function get() {\n      return this._isNorm;\n    },\n    set: function set(b) {\n      this._isNorm = b;\n    }\n  }], [{\n    key: \"from\",\n    value: function from() {\n      var p = [1, 1, 1, 1];\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var c = Util.getArgs(args);\n\n      for (var i = 0, len = p.length; i < len; i++) {\n        if (i < c.length) p[i] = c[i];\n      }\n\n      return new Color(p);\n    }\n  }, {\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      if (hex[0] == \"#\") hex = hex.substr(1);\n\n      if (hex.length <= 3) {\n        var fn = function fn(i) {\n          return hex[i] || \"F\";\n        };\n\n        hex = \"\".concat(fn(0)).concat(fn(0)).concat(fn(1)).concat(fn(1)).concat(fn(2)).concat(fn(2));\n      }\n\n      var alpha = 1;\n\n      if (hex.length === 8) {\n        alpha = hex.substr(6) && 0xFF / 255;\n        hex = hex.substring(0, 6);\n      }\n\n      var hexVal = parseInt(hex, 16);\n      return new Color(hexVal >> 16, hexVal >> 8 & 0xFF, hexVal & 0xFF, alpha);\n    }\n  }, {\n    key: \"rgb\",\n    value: function rgb() {\n      return Color.from.apply(Color, arguments).toMode(\"rgb\");\n    }\n  }, {\n    key: \"hsl\",\n    value: function hsl() {\n      return Color.from.apply(Color, arguments).toMode(\"hsl\");\n    }\n  }, {\n    key: \"hsb\",\n    value: function hsb() {\n      return Color.from.apply(Color, arguments).toMode(\"hsb\");\n    }\n  }, {\n    key: \"lab\",\n    value: function lab() {\n      return Color.from.apply(Color, arguments).toMode(\"lab\");\n    }\n  }, {\n    key: \"lch\",\n    value: function lch() {\n      return Color.from.apply(Color, arguments).toMode(\"lch\");\n    }\n  }, {\n    key: \"luv\",\n    value: function luv() {\n      return Color.from.apply(Color, arguments).toMode(\"luv\");\n    }\n  }, {\n    key: \"xyz\",\n    value: function xyz() {\n      return Color.from.apply(Color, arguments).toMode(\"xyz\");\n    }\n  }, {\n    key: \"maxValues\",\n    value: function maxValues(mode) {\n      return Color.ranges[mode].zipSlice(1).$take([0, 1, 2]);\n    }\n  }, {\n    key: \"RGBtoHSL\",\n    value: function RGBtoHSL(rgb) {\n      var normalizedInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var normalizedOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var _ref = !normalizedInput ? rgb.$normalize() : rgb,\n          _ref2 = _slicedToArray(_ref, 3),\n          r = _ref2[0],\n          g = _ref2[1],\n          b = _ref2[2];\n\n      var max = Math.max(r, g, b);\n      var min = Math.min(r, g, b);\n      var h = (max + min) / 2;\n      var s = h;\n      var l = h;\n\n      if (max == min) {\n        h = 0;\n        s = 0;\n      } else {\n        var d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        h = 0;\n\n        if (max === r) {\n          h = (g - b) / d + (g < b ? 6 : 0);\n        } else if (max === g) {\n          h = (b - r) / d + 2;\n        } else if (max === b) {\n          h = (r - g) / d + 4;\n        }\n      }\n\n      return Color.hsl(normalizedOutput ? h / 60 : h * 60, s, l, rgb.alpha);\n    }\n  }, {\n    key: \"HSLtoRGB\",\n    value: function HSLtoRGB(hsl) {\n      var normalizedInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var normalizedOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var _hsl = _slicedToArray(hsl, 3),\n          h = _hsl[0],\n          s = _hsl[1],\n          l = _hsl[2];\n\n      if (!normalizedInput) h = h / 360;\n      if (s == 0) return Color.rgb(l * 255, l * 255, l * 255, hsl.alpha);\n      var q = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n      var p = 2 * l - q;\n\n      var convert = function convert(t) {\n        t = t < 0 ? t + 1 : t > 1 ? t - 1 : t;\n\n        if (t * 6 < 1) {\n          return p + (q - p) * t * 6;\n        } else if (t * 2 < 1) {\n          return q;\n        } else if (t * 3 < 2) {\n          return p + (q - p) * (2 / 3 - t) * 6;\n        } else {\n          return p;\n        }\n      };\n\n      var sc = normalizedOutput ? 1 : 255;\n      return Color.rgb(sc * convert(h + 1 / 3), sc * convert(h), sc * convert(h - 1 / 3), hsl.alpha);\n    }\n  }, {\n    key: \"RGBtoHSB\",\n    value: function RGBtoHSB(rgb) {\n      var normalizedInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var normalizedOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var _ref3 = !normalizedInput ? rgb.$normalize() : rgb,\n          _ref4 = _slicedToArray(_ref3, 3),\n          r = _ref4[0],\n          g = _ref4[1],\n          b = _ref4[2];\n\n      var max = Math.max(r, g, b);\n      var min = Math.min(r, g, b);\n      var d = max - min;\n      var h = 0;\n      var s = max === 0 ? 0 : d / max;\n      var v = max;\n\n      if (max != min) {\n        if (max === r) {\n          h = (g - b) / d + (g < b ? 6 : 0);\n        } else if (max === g) {\n          h = (b - r) / d + 2;\n        } else if (max === b) {\n          h = (r - g) / d + 4;\n        }\n      }\n\n      return Color.hsb(normalizedOutput ? h / 60 : h * 60, s, v, rgb.alpha);\n    }\n  }, {\n    key: \"HSBtoRGB\",\n    value: function HSBtoRGB(hsb) {\n      var normalizedInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var normalizedOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var _hsb = _slicedToArray(hsb, 3),\n          h = _hsb[0],\n          s = _hsb[1],\n          v = _hsb[2];\n\n      if (!normalizedInput) h = h / 360;\n      var i = Math.floor(h * 6);\n      var f = h * 6 - i;\n      var p = v * (1 - s);\n      var q = v * (1 - f * s);\n      var t = v * (1 - (1 - f) * s);\n      var pick = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]];\n      var c = pick[i % 6];\n      var sc = normalizedOutput ? 1 : 255;\n      return Color.rgb(sc * c[0], sc * c[1], sc * c[2], hsb.alpha);\n    }\n  }, {\n    key: \"RGBtoLAB\",\n    value: function RGBtoLAB(rgb) {\n      var normalizedInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var normalizedOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var c = normalizedInput ? rgb.$normalize(false) : rgb;\n      return Color.XYZtoLAB(Color.RGBtoXYZ(c), false, normalizedOutput);\n    }\n  }, {\n    key: \"LABtoRGB\",\n    value: function LABtoRGB(lab) {\n      var normalizedInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var normalizedOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var c = normalizedInput ? lab.$normalize(false) : lab;\n      return Color.XYZtoRGB(Color.LABtoXYZ(c), false, normalizedOutput);\n    }\n  }, {\n    key: \"RGBtoLCH\",\n    value: function RGBtoLCH(rgb) {\n      var normalizedInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var normalizedOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var c = normalizedInput ? rgb.$normalize(false) : rgb;\n      return Color.LABtoLCH(Color.RGBtoLAB(c), false, normalizedOutput);\n    }\n  }, {\n    key: \"LCHtoRGB\",\n    value: function LCHtoRGB(lch) {\n      var normalizedInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var normalizedOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var c = normalizedInput ? lch.$normalize(false) : lch;\n      return Color.LABtoRGB(Color.LCHtoLAB(c), false, normalizedOutput);\n    }\n  }, {\n    key: \"RGBtoLUV\",\n    value: function RGBtoLUV(rgb) {\n      var normalizedInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var normalizedOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var c = normalizedInput ? rgb.$normalize(false) : rgb;\n      return Color.XYZtoLUV(Color.RGBtoXYZ(c), false, normalizedOutput);\n    }\n  }, {\n    key: \"LUVtoRGB\",\n    value: function LUVtoRGB(luv) {\n      var normalizedInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var normalizedOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var c = normalizedInput ? luv.$normalize(false) : luv;\n      return Color.XYZtoRGB(Color.LUVtoXYZ(c), false, normalizedOutput);\n    }\n  }, {\n    key: \"RGBtoXYZ\",\n    value: function RGBtoXYZ(rgb) {\n      var normalizedInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var normalizedOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var c = !normalizedInput ? rgb.$normalize() : rgb.clone();\n\n      for (var i = 0; i < 3; i++) {\n        c[i] = c[i] > 0.04045 ? Math.pow((c[i] + 0.055) / 1.055, 2.4) : c[i] / 12.92;\n        if (!normalizedOutput) c[i] = c[i] * 100;\n      }\n\n      var cc = Color.xyz(c[0] * 0.4124564 + c[1] * 0.3575761 + c[2] * 0.1804375, c[0] * 0.2126729 + c[1] * 0.7151522 + c[2] * 0.0721750, c[0] * 0.0193339 + c[1] * 0.1191920 + c[2] * 0.9503041, rgb.alpha);\n      return normalizedOutput ? cc.normalize() : cc;\n    }\n  }, {\n    key: \"XYZtoRGB\",\n    value: function XYZtoRGB(xyz) {\n      var normalizedInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var normalizedOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var _ref5 = !normalizedInput ? xyz.$normalize() : xyz,\n          _ref6 = _slicedToArray(_ref5, 3),\n          x = _ref6[0],\n          y = _ref6[1],\n          z = _ref6[2];\n\n      var rgb = [x * 3.2404542 + y * -1.5371385 + z * -0.4985314, x * -0.9692660 + y * 1.8760108 + z * 0.0415560, x * 0.0556434 + y * -0.2040259 + z * 1.0572252];\n\n      for (var i = 0; i < 3; i++) {\n        rgb[i] = rgb[i] < 0 ? 0 : rgb[i] > 0.0031308 ? 1.055 * Math.pow(rgb[i], 1 / 2.4) - 0.055 : 12.92 * rgb[i];\n        rgb[i] = Math.max(0, Math.min(1, rgb[i]));\n        if (!normalizedOutput) rgb[i] = Math.round(rgb[i] * 255);\n      }\n\n      var cc = Color.rgb(rgb[0], rgb[1], rgb[2], xyz.alpha);\n      return normalizedOutput ? cc.normalize() : cc;\n    }\n  }, {\n    key: \"XYZtoLAB\",\n    value: function XYZtoLAB(xyz) {\n      var normalizedInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var normalizedOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var c = normalizedInput ? xyz.$normalize(false) : xyz.clone();\n      c.divide(Color.D65);\n\n      var fn = function fn(n) {\n        return n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116;\n      };\n\n      var cy = fn(c[1]);\n      var cc = Color.lab(116 * cy - 16, 500 * (fn(c[0]) - cy), 200 * (cy - fn(c[2])), xyz.alpha);\n      return normalizedOutput ? cc.normalize() : cc;\n    }\n  }, {\n    key: \"LABtoXYZ\",\n    value: function LABtoXYZ(lab) {\n      var normalizedInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var normalizedOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var c = normalizedInput ? lab.$normalize(false) : lab;\n      var y = (c[0] + 16) / 116;\n      var x = c[1] / 500 + y;\n      var z = y - c[2] / 200;\n\n      var fn = function fn(n) {\n        var nnn = n * n * n;\n        return nnn > 0.008856 ? nnn : (n - 16 / 116) / 7.787;\n      };\n\n      var d = Color.D65;\n      var cc = Color.xyz(Math.max(0, d[0] * fn(x)), Math.max(0, d[1] * fn(y)), Math.max(0, d[2] * fn(z)), lab.alpha);\n      return normalizedOutput ? cc.normalize() : cc;\n    }\n  }, {\n    key: \"XYZtoLUV\",\n    value: function XYZtoLUV(xyz) {\n      var normalizedInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var normalizedOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var _ref7 = normalizedInput ? xyz.$normalize(false) : xyz,\n          _ref8 = _slicedToArray(_ref7, 3),\n          x = _ref8[0],\n          y = _ref8[1],\n          z = _ref8[2];\n\n      var u = 4 * x / (x + 15 * y + 3 * z);\n      var v = 9 * y / (x + 15 * y + 3 * z);\n      y = y / 100;\n      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n      var refU = 4 * Color.D65[0] / (Color.D65[0] + 15 * Color.D65[1] + 3 * Color.D65[2]);\n      var refV = 9 * Color.D65[1] / (Color.D65[0] + 15 * Color.D65[1] + 3 * Color.D65[2]);\n      var L = 116 * y - 16;\n      return Color.luv(L, 13 * L * (u - refU), 13 * L * (v - refV), xyz.alpha);\n    }\n  }, {\n    key: \"LUVtoXYZ\",\n    value: function LUVtoXYZ(luv) {\n      var normalizedInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var normalizedOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var _ref9 = normalizedInput ? luv.$normalize(false) : luv,\n          _ref10 = _slicedToArray(_ref9, 3),\n          l = _ref10[0],\n          u = _ref10[1],\n          v = _ref10[2];\n\n      var y = (l + 16) / 116;\n      var cubeY = y * y * y;\n      y = cubeY > 0.008856 ? cubeY : (y - 16 / 116) / 7.787;\n      var refU = 4 * Color.D65[0] / (Color.D65[0] + 15 * Color.D65[1] + 3 * Color.D65[2]);\n      var refV = 9 * Color.D65[1] / (Color.D65[0] + 15 * Color.D65[1] + 3 * Color.D65[2]);\n      u = u / (13 * l) + refU;\n      v = v / (13 * l) + refV;\n      y = y * 100;\n      var x = -1 * (9 * y * u) / ((u - 4) * v - u * v);\n      var z = (9 * y - 15 * v * y - v * x) / (3 * v);\n      return Color.xyz(x, y, z, luv.alpha);\n    }\n  }, {\n    key: \"LABtoLCH\",\n    value: function LABtoLCH(lab) {\n      var normalizedInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var normalizedOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var c = normalizedInput ? lab.$normalize(false) : lab;\n      var h = Geom.toDegree(Geom.boundRadian(Math.atan2(c[2], c[1])));\n      return Color.lch(c[0], Math.sqrt(c[1] * c[1] + c[2] * c[2]), h, lab.alpha);\n    }\n  }, {\n    key: \"LCHtoLAB\",\n    value: function LCHtoLAB(lch) {\n      var normalizedInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var normalizedOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var c = normalizedInput ? lch.$normalize(false) : lch;\n      var rad = Geom.toRadian(c[2]);\n      return Color.lab(c[0], Math.cos(rad) * c[1], Math.sin(rad) * c[1], lch.alpha);\n    }\n  }]);\n\n  return Color;\n}(Pt);\nColor.D65 = new Pt(95.047, 100, 108.883, 1);\nColor.ranges = {\n  rgb: new Group(new Pt(0, 255), new Pt(0, 255), new Pt(0, 255)),\n  hsl: new Group(new Pt(0, 360), new Pt(0, 1), new Pt(0, 1)),\n  hsb: new Group(new Pt(0, 360), new Pt(0, 1), new Pt(0, 1)),\n  lab: new Group(new Pt(0, 100), new Pt(-128, 127), new Pt(-128, 127)),\n  lch: new Group(new Pt(0, 100), new Pt(0, 100), new Pt(0, 360)),\n  luv: new Group(new Pt(0, 100), new Pt(-134, 220), new Pt(-140, 122)),\n  xyz: new Group(new Pt(0, 100), new Pt(0, 100), new Pt(0, 100))\n};","map":null,"metadata":{},"sourceType":"module"}