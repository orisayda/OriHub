{"ast":null,"code":"import _possibleConstructorReturn from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _classCallCheck from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/*! Source code licensed under Apache License 2.0. Copyright Â© 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Pt, Group } from \"./Pt\";\nimport { Rectangle, Circle, Polygon } from \"./Op\";\nexport var UIShape = {\n  rectangle: \"rectangle\",\n  circle: \"circle\",\n  polygon: \"polygon\",\n  polyline: \"polyline\",\n  line: \"line\"\n};\nexport var UIPointerActions = {\n  up: \"up\",\n  down: \"down\",\n  move: \"move\",\n  drag: \"drag\",\n  uidrag: \"uidrag\",\n  drop: \"drop\",\n  over: \"over\",\n  out: \"out\",\n  enter: \"enter\",\n  leave: \"leave\",\n  all: \"all\"\n};\nexport var UI =\n/*#__PURE__*/\nfunction () {\n  function UI(group, shape) {\n    var states = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var id = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, UI);\n\n    this._holds = [];\n    this._group = Group.fromArray(group);\n    this._shape = shape;\n    this._id = id === undefined ? \"ui_\".concat(UI._counter++) : id;\n    this._states = states;\n    this._actions = {};\n  }\n\n  _createClass(UI, [{\n    key: \"state\",\n    value: function state(key, value) {\n      if (!key) return null;\n\n      if (value !== undefined) {\n        this._states[key] = value;\n        return this;\n      }\n\n      return this._states[key];\n    }\n  }, {\n    key: \"on\",\n    value: function on(key, fn) {\n      if (!this._actions[key]) this._actions[key] = [];\n      return UI._addHandler(this._actions[key], fn);\n    }\n  }, {\n    key: \"off\",\n    value: function off(key, which) {\n      if (!this._actions[key]) return false;\n\n      if (which === undefined) {\n        delete this._actions[key];\n        return true;\n      } else {\n        return UI._removeHandler(this._actions[key], which);\n      }\n    }\n  }, {\n    key: \"listen\",\n    value: function listen(key, p) {\n      if (this._actions[key] !== undefined) {\n        if (this._within(p) || this._holds.indexOf(key) >= 0) {\n          UI._trigger(this._actions[key], this, p, key);\n\n          return true;\n        } else if (this._actions['all']) {\n          UI._trigger(this._actions['all'], this, p, key);\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"hold\",\n    value: function hold(key) {\n      this._holds.push(key);\n\n      return this._holds.length - 1;\n    }\n  }, {\n    key: \"unhold\",\n    value: function unhold(id) {\n      if (id !== undefined) {\n        this._holds = this._holds.splice(id, 1);\n      } else {\n        this._holds = [];\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(fn) {\n      fn(this._group, this._states);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"UI \".concat(this.group.toString);\n    }\n  }, {\n    key: \"_within\",\n    value: function _within(p) {\n      var fn = null;\n\n      if (this._shape === UIShape.rectangle) {\n        fn = Rectangle.withinBound;\n      } else if (this._shape === UIShape.circle) {\n        fn = Circle.withinBound;\n      } else if (this._shape === UIShape.polygon) {\n        fn = Polygon.hasIntersectPoint;\n      } else {\n        return false;\n      }\n\n      return fn(this._group, p);\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    },\n    set: function set(d) {\n      this._id = d;\n    }\n  }, {\n    key: \"group\",\n    get: function get() {\n      return this._group;\n    },\n    set: function set(d) {\n      this._group = d;\n    }\n  }, {\n    key: \"shape\",\n    get: function get() {\n      return this._shape;\n    },\n    set: function set(d) {\n      this._shape = d;\n    }\n  }], [{\n    key: \"fromRectangle\",\n    value: function fromRectangle(group, states, id) {\n      return new this(group, UIShape.rectangle, states, id);\n    }\n  }, {\n    key: \"fromCircle\",\n    value: function fromCircle(group, states, id) {\n      return new this(group, UIShape.circle, states, id);\n    }\n  }, {\n    key: \"fromPolygon\",\n    value: function fromPolygon(group, states, id) {\n      return new this(group, UIShape.polygon, states, id);\n    }\n  }, {\n    key: \"fromUI\",\n    value: function fromUI(ui, states, id) {\n      return new this(ui.group, ui.shape, states || ui._states, id);\n    }\n  }, {\n    key: \"track\",\n    value: function track(uis, key, p) {\n      for (var i = 0, len = uis.length; i < len; i++) {\n        uis[i].listen(key, p);\n      }\n    }\n  }, {\n    key: \"_trigger\",\n    value: function _trigger(fns, target, pt, type) {\n      if (fns) {\n        for (var i = 0, len = fns.length; i < len; i++) {\n          if (fns[i]) fns[i](target, pt, type);\n        }\n      }\n    }\n  }, {\n    key: \"_addHandler\",\n    value: function _addHandler(fns, fn) {\n      if (fn) {\n        fns.push(fn);\n        return fns.length - 1;\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: \"_removeHandler\",\n    value: function _removeHandler(fns, index) {\n      if (index >= 0 && index < fns.length) {\n        var temp = fns.length;\n        fns.splice(index, 1);\n        return temp > fns.length;\n      } else {\n        return false;\n      }\n    }\n  }]);\n\n  return UI;\n}();\nUI._counter = 0;\nexport var UIButton =\n/*#__PURE__*/\nfunction (_UI) {\n  _inherits(UIButton, _UI);\n\n  function UIButton(group, shape) {\n    var _this;\n\n    var states = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var id = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, UIButton);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(UIButton).call(this, group, shape, states, id));\n    _this._hoverID = -1;\n    if (states.hover === undefined) _this._states['hover'] = false;\n    if (states.clicks === undefined) _this._states['clicks'] = 0;\n    var UA = UIPointerActions;\n\n    _this.on(UA.up, function (target, pt, type) {\n      _this.state('clicks', _this._states.clicks + 1);\n    });\n\n    _this.on(UA.move, function (target, pt, type) {\n      var hover = _this._within(pt);\n\n      if (hover && !_this._states.hover) {\n        _this.state('hover', true);\n\n        UI._trigger(_this._actions[UA.enter], _assertThisInitialized(_assertThisInitialized(_this)), pt, UA.enter);\n\n        var _capID = _this.hold(UA.move);\n\n        _this._hoverID = _this.on(UA.move, function (t, p) {\n          if (!_this._within(p) && !_this.state('dragging')) {\n            _this.state('hover', false);\n\n            UI._trigger(_this._actions[UA.leave], _assertThisInitialized(_assertThisInitialized(_this)), pt, UA.leave);\n\n            _this.off(UA.move, _this._hoverID);\n\n            _this.unhold(_capID);\n          }\n        });\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(UIButton, [{\n    key: \"onClick\",\n    value: function onClick(fn) {\n      return this.on(UIPointerActions.up, fn);\n    }\n  }, {\n    key: \"offClick\",\n    value: function offClick(id) {\n      return this.off(UIPointerActions.up, id);\n    }\n  }, {\n    key: \"onHover\",\n    value: function onHover(enter, leave) {\n      var ids = [undefined, undefined];\n      if (enter) ids[0] = this.on(UIPointerActions.enter, enter);\n      if (leave) ids[1] = this.on(UIPointerActions.leave, leave);\n      return ids;\n    }\n  }, {\n    key: \"offHover\",\n    value: function offHover(enterID, leaveID) {\n      var s = [false, false];\n      if (enterID === undefined || enterID >= 0) s[0] = this.off(UIPointerActions.enter, enterID);\n      if (leaveID === undefined || leaveID >= 0) s[1] = this.off(UIPointerActions.leave, leaveID);\n      return s;\n    }\n  }]);\n\n  return UIButton;\n}(UI);\nexport var UIDragger =\n/*#__PURE__*/\nfunction (_UIButton) {\n  _inherits(UIDragger, _UIButton);\n\n  function UIDragger(group, shape) {\n    var _this2;\n\n    var states = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var id = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, UIDragger);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(UIDragger).call(this, group, shape, states, id));\n    _this2._draggingID = -1;\n    _this2._moveHoldID = -1;\n    if (states.dragging === undefined) _this2._states['dragging'] = false;\n    if (states.offset === undefined) _this2._states['offset'] = new Pt();\n    var UA = UIPointerActions;\n\n    _this2.on(UA.down, function (target, pt, type) {\n      _this2.state('dragging', true);\n\n      _this2.state('offset', new Pt(pt).subtract(target.group[0]));\n\n      _this2._moveHoldID = _this2.hold(UA.move);\n      _this2._draggingID = _this2.on(UA.move, function (t, p) {\n        if (_this2.state('dragging')) {\n          UI._trigger(_this2._actions[UA.uidrag], t, p, UA.uidrag);\n        }\n      });\n    });\n\n    _this2.on(UA.up, function (target, pt, type) {\n      _this2.state('dragging', false);\n\n      _this2.off(UA.move, _this2._draggingID);\n\n      _this2.unhold(_this2._moveHoldID);\n\n      UI._trigger(_this2._actions[UA.drop], target, pt, type);\n    });\n\n    return _this2;\n  }\n\n  _createClass(UIDragger, [{\n    key: \"onDrag\",\n    value: function onDrag(fn) {\n      return this.on(UIPointerActions.uidrag, fn);\n    }\n  }, {\n    key: \"offDrag\",\n    value: function offDrag(id) {\n      return this.off(UIPointerActions.uidrag, id);\n    }\n  }, {\n    key: \"onDrop\",\n    value: function onDrop(fn) {\n      return this.on(UIPointerActions.drop, fn);\n    }\n  }, {\n    key: \"offDrop\",\n    value: function offDrop(id) {\n      return this.off(UIPointerActions.drop, id);\n    }\n  }]);\n\n  return UIDragger;\n}(UIButton);","map":null,"metadata":{},"sourceType":"module"}