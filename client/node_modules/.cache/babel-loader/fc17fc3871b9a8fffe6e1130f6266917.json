{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _wrapNativeSuper from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/wrapNativeSuper\";\n\n/*! Source code licensed under Apache License 2.0. Copyright Â© 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Util, Const } from \"./Util\";\nimport { Geom, Num } from \"./Num\";\nimport { Vec, Mat } from \"./LinearAlgebra\";\nexport var Pt =\n/*#__PURE__*/\nfunction (_Float32Array) {\n  _inherits(Pt, _Float32Array);\n\n  function Pt() {\n    var _this;\n\n    _classCallCheck(this, Pt);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (args.length === 1 && typeof args[0] == \"number\") {\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Pt).call(this, args[0]));\n    } else {\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Pt).call(this, args.length > 0 ? Util.getArgs(args) : [0, 0]));\n    }\n\n    return _possibleConstructorReturn(_this);\n  }\n\n  _createClass(Pt, [{\n    key: \"clone\",\n    value: function clone() {\n      return new Pt(this);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(p) {\n      var threshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.000001;\n\n      for (var i = 0, len = this.length; i < len; i++) {\n        if (Math.abs(this[i] - p[i]) > threshold) return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"to\",\n    value: function to() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var p = Util.getArgs(args);\n\n      for (var i = 0, len = Math.min(this.length, p.length); i < len; i++) {\n        this[i] = p[i];\n      }\n\n      return this;\n    }\n  }, {\n    key: \"$to\",\n    value: function $to() {\n      var _this$clone;\n\n      return (_this$clone = this.clone()).to.apply(_this$clone, arguments);\n    }\n  }, {\n    key: \"toAngle\",\n    value: function toAngle(radian, magnitude) {\n      var anchorFromPt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var m = magnitude != undefined ? magnitude : this.magnitude();\n      var change = [Math.cos(radian) * m, Math.sin(radian) * m];\n      return anchorFromPt ? this.add(change) : this.to(change);\n    }\n  }, {\n    key: \"op\",\n    value: function op(fn) {\n      var self = this;\n      return function () {\n        for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          params[_key3] = arguments[_key3];\n        }\n\n        return fn.apply(void 0, [self].concat(params));\n      };\n    }\n  }, {\n    key: \"ops\",\n    value: function ops(fns) {\n      var _ops = [];\n\n      for (var i = 0, len = fns.length; i < len; i++) {\n        _ops.push(this.op(fns[i]));\n      }\n\n      return _ops;\n    }\n  }, {\n    key: \"$take\",\n    value: function $take(axis) {\n      var p = [];\n\n      for (var i = 0, len = axis.length; i < len; i++) {\n        p.push(this[axis[i]] || 0);\n      }\n\n      return new Pt(p);\n    }\n  }, {\n    key: \"$concat\",\n    value: function $concat() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return new Pt(this.toArray().concat(Util.getArgs(args)));\n    }\n  }, {\n    key: \"add\",\n    value: function add() {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      args.length === 1 && typeof args[0] == \"number\" ? Vec.add(this, args[0]) : Vec.add(this, Util.getArgs(args));\n      return this;\n    }\n  }, {\n    key: \"$add\",\n    value: function $add() {\n      var _this$clone2;\n\n      return (_this$clone2 = this.clone()).add.apply(_this$clone2, arguments);\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      args.length === 1 && typeof args[0] == \"number\" ? Vec.subtract(this, args[0]) : Vec.subtract(this, Util.getArgs(args));\n      return this;\n    }\n  }, {\n    key: \"$subtract\",\n    value: function $subtract() {\n      var _this$clone3;\n\n      return (_this$clone3 = this.clone()).subtract.apply(_this$clone3, arguments);\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply() {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      args.length === 1 && typeof args[0] == \"number\" ? Vec.multiply(this, args[0]) : Vec.multiply(this, Util.getArgs(args));\n      return this;\n    }\n  }, {\n    key: \"$multiply\",\n    value: function $multiply() {\n      var _this$clone4;\n\n      return (_this$clone4 = this.clone()).multiply.apply(_this$clone4, arguments);\n    }\n  }, {\n    key: \"divide\",\n    value: function divide() {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n\n      args.length === 1 && typeof args[0] == \"number\" ? Vec.divide(this, args[0]) : Vec.divide(this, Util.getArgs(args));\n      return this;\n    }\n  }, {\n    key: \"$divide\",\n    value: function $divide() {\n      var _this$clone5;\n\n      return (_this$clone5 = this.clone()).divide.apply(_this$clone5, arguments);\n    }\n  }, {\n    key: \"magnitudeSq\",\n    value: function magnitudeSq() {\n      return Vec.dot(this, this);\n    }\n  }, {\n    key: \"magnitude\",\n    value: function magnitude() {\n      return Vec.magnitude(this);\n    }\n  }, {\n    key: \"unit\",\n    value: function unit() {\n      var magnitude = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      Vec.unit(this, magnitude);\n      return this;\n    }\n  }, {\n    key: \"$unit\",\n    value: function $unit() {\n      var magnitude = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      return this.clone().unit(magnitude);\n    }\n  }, {\n    key: \"dot\",\n    value: function dot() {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n\n      return Vec.dot(this, Util.getArgs(args));\n    }\n  }, {\n    key: \"$cross2D\",\n    value: function $cross2D() {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n\n      return Vec.cross2D(this, Util.getArgs(args));\n    }\n  }, {\n    key: \"$cross\",\n    value: function $cross() {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n\n      return Vec.cross(this, Util.getArgs(args));\n    }\n  }, {\n    key: \"$project\",\n    value: function $project() {\n      return this.$multiply(this.dot.apply(this, arguments) / this.magnitudeSq());\n    }\n  }, {\n    key: \"projectScalar\",\n    value: function projectScalar() {\n      return this.dot.apply(this, arguments) / this.magnitude();\n    }\n  }, {\n    key: \"abs\",\n    value: function abs() {\n      Vec.abs(this);\n      return this;\n    }\n  }, {\n    key: \"$abs\",\n    value: function $abs() {\n      return this.clone().abs();\n    }\n  }, {\n    key: \"floor\",\n    value: function floor() {\n      Vec.floor(this);\n      return this;\n    }\n  }, {\n    key: \"$floor\",\n    value: function $floor() {\n      return this.clone().floor();\n    }\n  }, {\n    key: \"ceil\",\n    value: function ceil() {\n      Vec.ceil(this);\n      return this;\n    }\n  }, {\n    key: \"$ceil\",\n    value: function $ceil() {\n      return this.clone().ceil();\n    }\n  }, {\n    key: \"round\",\n    value: function round() {\n      Vec.round(this);\n      return this;\n    }\n  }, {\n    key: \"$round\",\n    value: function $round() {\n      return this.clone().round();\n    }\n  }, {\n    key: \"minValue\",\n    value: function minValue() {\n      return Vec.min(this);\n    }\n  }, {\n    key: \"maxValue\",\n    value: function maxValue() {\n      return Vec.max(this);\n    }\n  }, {\n    key: \"$min\",\n    value: function $min() {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n\n      var p = Util.getArgs(args);\n      var m = this.clone();\n\n      for (var i = 0, len = Math.min(this.length, p.length); i < len; i++) {\n        m[i] = Math.min(this[i], p[i]);\n      }\n\n      return m;\n    }\n  }, {\n    key: \"$max\",\n    value: function $max() {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n\n      var p = Util.getArgs(args);\n      var m = this.clone();\n\n      for (var i = 0, len = Math.min(this.length, p.length); i < len; i++) {\n        m[i] = Math.max(this[i], p[i]);\n      }\n\n      return m;\n    }\n  }, {\n    key: \"angle\",\n    value: function angle() {\n      var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Const.xy;\n      return Math.atan2(this[axis[1]], this[axis[0]]);\n    }\n  }, {\n    key: \"angleBetween\",\n    value: function angleBetween(p) {\n      var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Const.xy;\n      return Geom.boundRadian(this.angle(axis)) - Geom.boundRadian(p.angle(axis));\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(_scale, anchor) {\n      Geom.scale(this, _scale, anchor || Pt.make(this.length, 0));\n      return this;\n    }\n  }, {\n    key: \"rotate2D\",\n    value: function rotate2D(angle, anchor, axis) {\n      Geom.rotate2D(this, angle, anchor || Pt.make(this.length, 0), axis);\n      return this;\n    }\n  }, {\n    key: \"shear2D\",\n    value: function shear2D(scale, anchor, axis) {\n      Geom.shear2D(this, scale, anchor || Pt.make(this.length, 0), axis);\n      return this;\n    }\n  }, {\n    key: \"reflect2D\",\n    value: function reflect2D(line, axis) {\n      Geom.reflect2D(this, line, axis);\n      return this;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Pt(\".concat(this.join(\", \"), \")\");\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return [].slice.call(this);\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    },\n    set: function set(s) {\n      this._id = s;\n    }\n  }, {\n    key: \"x\",\n    get: function get() {\n      return this[0];\n    },\n    set: function set(n) {\n      this[0] = n;\n    }\n  }, {\n    key: \"y\",\n    get: function get() {\n      return this[1];\n    },\n    set: function set(n) {\n      this[1] = n;\n    }\n  }, {\n    key: \"z\",\n    get: function get() {\n      return this[2];\n    },\n    set: function set(n) {\n      this[2] = n;\n    }\n  }, {\n    key: \"w\",\n    get: function get() {\n      return this[3];\n    },\n    set: function set(n) {\n      this[3] = n;\n    }\n  }], [{\n    key: \"make\",\n    value: function make(dimensions) {\n      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var randomize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var p = new Float32Array(dimensions);\n      if (defaultValue) p.fill(defaultValue);\n\n      if (randomize) {\n        for (var i = 0, len = p.length; i < len; i++) {\n          p[i] = p[i] * Math.random();\n        }\n      }\n\n      return new Pt(p);\n    }\n  }]);\n\n  return Pt;\n}(_wrapNativeSuper(Float32Array));\nexport var Group =\n/*#__PURE__*/\nfunction (_Array) {\n  _inherits(Group, _Array);\n\n  function Group() {\n    var _getPrototypeOf2;\n\n    _classCallCheck(this, Group);\n\n    for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n      args[_key14] = arguments[_key14];\n    }\n\n    return _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Group)).call.apply(_getPrototypeOf2, [this].concat(args)));\n  }\n\n  _createClass(Group, [{\n    key: \"clone\",\n    value: function clone() {\n      var group = new Group();\n\n      for (var i = 0, len = this.length; i < len; i++) {\n        group.push(this[i].clone());\n      }\n\n      return group;\n    }\n  }, {\n    key: \"split\",\n    value: function split(chunkSize, stride) {\n      var loopBack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var sp = Util.split(this, chunkSize, stride, loopBack);\n      return sp;\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(pts) {\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      Group.prototype.splice.apply(this, [index, 0].concat(_toConsumableArray(pts)));\n      return this;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var param = index < 0 ? [index * -1 - 1, count] : [index, count];\n      return Group.prototype.splice.apply(this, param);\n    }\n  }, {\n    key: \"segments\",\n    value: function segments() {\n      var pts_per_segment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n      var stride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var loopBack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      return this.split(pts_per_segment, stride, loopBack);\n    }\n  }, {\n    key: \"lines\",\n    value: function lines() {\n      return this.segments(2, 1);\n    }\n  }, {\n    key: \"centroid\",\n    value: function centroid() {\n      return Geom.centroid(this);\n    }\n  }, {\n    key: \"boundingBox\",\n    value: function boundingBox() {\n      return Geom.boundingBox(this);\n    }\n  }, {\n    key: \"anchorTo\",\n    value: function anchorTo() {\n      var ptOrIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      Geom.anchor(this, ptOrIndex, \"to\");\n    }\n  }, {\n    key: \"anchorFrom\",\n    value: function anchorFrom() {\n      var ptOrIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      Geom.anchor(this, ptOrIndex, \"from\");\n    }\n  }, {\n    key: \"op\",\n    value: function op(fn) {\n      var self = this;\n      return function () {\n        for (var _len15 = arguments.length, params = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n          params[_key15] = arguments[_key15];\n        }\n\n        return fn.apply(void 0, [self].concat(params));\n      };\n    }\n  }, {\n    key: \"ops\",\n    value: function ops(fns) {\n      var _ops = [];\n\n      for (var i = 0, len = fns.length; i < len; i++) {\n        _ops.push(this.op(fns[i]));\n      }\n\n      return _ops;\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate(t) {\n      t = Num.clamp(t, 0, 1);\n      var chunk = this.length - 1;\n      var tc = 1 / (this.length - 1);\n      var idx = Math.floor(t / tc);\n      return Geom.interpolate(this[idx], this[Math.min(this.length - 1, idx + 1)], (t - idx * tc) * chunk);\n    }\n  }, {\n    key: \"moveBy\",\n    value: function moveBy() {\n      return this.add.apply(this, arguments);\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo() {\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n\n      var d = new Pt(Util.getArgs(args)).subtract(this[0]);\n      this.moveBy(d);\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(_scale2, anchor) {\n      for (var i = 0, len = this.length; i < len; i++) {\n        Geom.scale(this[i], _scale2, anchor || this[0]);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"rotate2D\",\n    value: function rotate2D(angle, anchor, axis) {\n      for (var i = 0, len = this.length; i < len; i++) {\n        Geom.rotate2D(this[i], angle, anchor || this[0], axis);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"shear2D\",\n    value: function shear2D(scale, anchor, axis) {\n      for (var i = 0, len = this.length; i < len; i++) {\n        Geom.shear2D(this[i], scale, anchor || this[0], axis);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"reflect2D\",\n    value: function reflect2D(line, axis) {\n      for (var i = 0, len = this.length; i < len; i++) {\n        Geom.reflect2D(this[i], line, axis);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"sortByDimension\",\n    value: function sortByDimension(dim) {\n      var desc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.sort(function (a, b) {\n        return desc ? b[dim] - a[dim] : a[dim] - b[dim];\n      });\n    }\n  }, {\n    key: \"forEachPt\",\n    value: function forEachPt(ptFn) {\n      if (!this[0][ptFn]) {\n        Util.warn(\"\".concat(ptFn, \" is not a function of Pt\"));\n        return this;\n      }\n\n      for (var _len17 = arguments.length, args = new Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) {\n        args[_key17 - 1] = arguments[_key17];\n      }\n\n      for (var i = 0, len = this.length; i < len; i++) {\n        var _this$i;\n\n        this[i] = (_this$i = this[i])[ptFn].apply(_this$i, args);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"add\",\n    value: function add() {\n      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n        args[_key18] = arguments[_key18];\n      }\n\n      return this.forEachPt.apply(this, [\"add\"].concat(args));\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract() {\n      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n        args[_key19] = arguments[_key19];\n      }\n\n      return this.forEachPt.apply(this, [\"subtract\"].concat(args));\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply() {\n      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n        args[_key20] = arguments[_key20];\n      }\n\n      return this.forEachPt.apply(this, [\"multiply\"].concat(args));\n    }\n  }, {\n    key: \"divide\",\n    value: function divide() {\n      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n        args[_key21] = arguments[_key21];\n      }\n\n      return this.forEachPt.apply(this, [\"divide\"].concat(args));\n    }\n  }, {\n    key: \"$matrixAdd\",\n    value: function $matrixAdd(g) {\n      return Mat.add(this, g);\n    }\n  }, {\n    key: \"$matrixMultiply\",\n    value: function $matrixMultiply(g) {\n      var transposed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var elementwise = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      return Mat.multiply(this, g, transposed, elementwise);\n    }\n  }, {\n    key: \"zipSlice\",\n    value: function zipSlice(index) {\n      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return Mat.zipSlice(this, index, defaultValue);\n    }\n  }, {\n    key: \"$zip\",\n    value: function $zip() {\n      var defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var useLongest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return Mat.zip(this, defaultValue, useLongest);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Group[ \" + this.reduce(function (p, c) {\n        return p + c.toString() + \" \";\n      }, \"\") + \" ]\";\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    },\n    set: function set(s) {\n      this._id = s;\n    }\n  }, {\n    key: \"p1\",\n    get: function get() {\n      return this[0];\n    }\n  }, {\n    key: \"p2\",\n    get: function get() {\n      return this[1];\n    }\n  }, {\n    key: \"p3\",\n    get: function get() {\n      return this[2];\n    }\n  }, {\n    key: \"p4\",\n    get: function get() {\n      return this[3];\n    }\n  }, {\n    key: \"q1\",\n    get: function get() {\n      return this[this.length - 1];\n    }\n  }, {\n    key: \"q2\",\n    get: function get() {\n      return this[this.length - 2];\n    }\n  }, {\n    key: \"q3\",\n    get: function get() {\n      return this[this.length - 3];\n    }\n  }, {\n    key: \"q4\",\n    get: function get() {\n      return this[this.length - 4];\n    }\n  }], [{\n    key: \"fromArray\",\n    value: function fromArray(list) {\n      var g = new Group();\n\n      for (var i = 0, len = list.length; i < len; i++) {\n        var p = list[i] instanceof Pt ? list[i] : new Pt(list[i]);\n        g.push(p);\n      }\n\n      return g;\n    }\n  }, {\n    key: \"fromPtArray\",\n    value: function fromPtArray(list) {\n      return Group.from(list);\n    }\n  }]);\n\n  return Group;\n}(_wrapNativeSuper(Array));\nexport var Bound =\n/*#__PURE__*/\nfunction (_Group) {\n  _inherits(Bound, _Group);\n\n  function Bound() {\n    var _getPrototypeOf3;\n\n    var _this2;\n\n    _classCallCheck(this, Bound);\n\n    for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n      args[_key22] = arguments[_key22];\n    }\n\n    _this2 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(Bound)).call.apply(_getPrototypeOf3, [this].concat(args)));\n    _this2._center = new Pt();\n    _this2._size = new Pt();\n    _this2._topLeft = new Pt();\n    _this2._bottomRight = new Pt();\n    _this2._inited = false;\n\n    _this2.init();\n\n    return _this2;\n  }\n\n  _createClass(Bound, [{\n    key: \"init\",\n    value: function init() {\n      if (this.p1) {\n        this._size = this.p1.clone();\n        this._inited = true;\n      }\n\n      if (this.p1 && this.p2) {\n        var a = this.p1;\n        var b = this.p2;\n        this.topLeft = a.$min(b);\n        this._bottomRight = a.$max(b);\n\n        this._updateSize();\n\n        this._inited = true;\n      }\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Bound(this._topLeft.clone(), this._bottomRight.clone());\n    }\n  }, {\n    key: \"_updateSize\",\n    value: function _updateSize() {\n      this._size = this._bottomRight.$subtract(this._topLeft).abs();\n\n      this._updateCenter();\n    }\n  }, {\n    key: \"_updateCenter\",\n    value: function _updateCenter() {\n      this._center = this._size.$multiply(0.5).add(this._topLeft);\n    }\n  }, {\n    key: \"_updatePosFromTop\",\n    value: function _updatePosFromTop() {\n      this._bottomRight = this._topLeft.$add(this._size);\n\n      this._updateCenter();\n    }\n  }, {\n    key: \"_updatePosFromBottom\",\n    value: function _updatePosFromBottom() {\n      this._topLeft = this._bottomRight.$subtract(this._size);\n\n      this._updateCenter();\n    }\n  }, {\n    key: \"_updatePosFromCenter\",\n    value: function _updatePosFromCenter() {\n      var half = this._size.$multiply(0.5);\n\n      this._topLeft = this._center.$subtract(half);\n      this._bottomRight = this._center.$add(half);\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this._topLeft = this[0];\n      this._bottomRight = this[1];\n\n      this._updateSize();\n\n      return this;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return new Pt(this._size);\n    },\n    set: function set(p) {\n      this._size = new Pt(p);\n\n      this._updatePosFromTop();\n    }\n  }, {\n    key: \"center\",\n    get: function get() {\n      return new Pt(this._center);\n    },\n    set: function set(p) {\n      this._center = new Pt(p);\n\n      this._updatePosFromCenter();\n    }\n  }, {\n    key: \"topLeft\",\n    get: function get() {\n      return new Pt(this._topLeft);\n    },\n    set: function set(p) {\n      this._topLeft = new Pt(p);\n      this[0] = this._topLeft;\n\n      this._updateSize();\n    }\n  }, {\n    key: \"bottomRight\",\n    get: function get() {\n      return new Pt(this._bottomRight);\n    },\n    set: function set(p) {\n      this._bottomRight = new Pt(p);\n      this[1] = this._bottomRight;\n\n      this._updateSize();\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this._size.length > 0 ? this._size.x : 0;\n    },\n    set: function set(w) {\n      this._size.x = w;\n\n      this._updatePosFromTop();\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this._size.length > 1 ? this._size.y : 0;\n    },\n    set: function set(h) {\n      this._size.y = h;\n\n      this._updatePosFromTop();\n    }\n  }, {\n    key: \"depth\",\n    get: function get() {\n      return this._size.length > 2 ? this._size.z : 0;\n    },\n    set: function set(d) {\n      this._size.z = d;\n\n      this._updatePosFromTop();\n    }\n  }, {\n    key: \"x\",\n    get: function get() {\n      return this.topLeft.x;\n    }\n  }, {\n    key: \"y\",\n    get: function get() {\n      return this.topLeft.y;\n    }\n  }, {\n    key: \"z\",\n    get: function get() {\n      return this.topLeft.z;\n    }\n  }, {\n    key: \"inited\",\n    get: function get() {\n      return this._inited;\n    }\n  }], [{\n    key: \"fromBoundingRect\",\n    value: function fromBoundingRect(rect) {\n      var b = new Bound(new Pt(rect.left || 0, rect.top || 0), new Pt(rect.right || 0, rect.bottom || 0));\n      if (rect.width && rect.height) b.size = new Pt(rect.width, rect.height);\n      return b;\n    }\n  }, {\n    key: \"fromGroup\",\n    value: function fromGroup(g) {\n      if (g.length < 2) throw new Error(\"Cannot create a Bound from a group that has less than 2 Pt\");\n      return new Bound(g[0], g[g.length - 1]);\n    }\n  }]);\n\n  return Bound;\n}(Group);","map":null,"metadata":{},"sourceType":"module"}