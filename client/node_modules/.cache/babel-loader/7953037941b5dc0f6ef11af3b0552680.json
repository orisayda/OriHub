{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _inherits from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\n\n/*! Source code licensed under Apache License 2.0. Copyright Â© 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { MultiTouchSpace } from './Space';\nimport { VisualForm, Font } from \"./Form\";\nimport { Pt, Group, Bound } from \"./Pt\";\nimport { Const } from \"./Util\";\nimport { Typography as Typo } from \"./Typography\";\nimport { Rectangle } from './Op';\nexport var CanvasSpace =\n/*#__PURE__*/\nfunction (_MultiTouchSpace) {\n  _inherits(CanvasSpace, _MultiTouchSpace);\n\n  function CanvasSpace(elem, callback) {\n    var _this;\n\n    _classCallCheck(this, CanvasSpace);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CanvasSpace).call(this));\n    _this._pixelScale = 1;\n    _this._autoResize = true;\n    _this._bgcolor = \"#e1e9f0\";\n    _this._offscreen = false;\n    _this._initialResize = false;\n    var _selector = null;\n    var _existed = false;\n    _this.id = \"pt\";\n\n    if (elem instanceof Element) {\n      _selector = elem;\n      _this.id = \"pts_existing_space\";\n    } else {\n      var id = elem;\n      id = elem[0] === \"#\" || elem[0] === \".\" ? elem : \"#\" + elem;\n      _selector = document.querySelector(id);\n      _existed = true;\n      _this.id = id.substr(1);\n    }\n\n    if (!_selector) {\n      _this._container = _this._createElement(\"div\", _this.id + \"_container\");\n      _this._canvas = _this._createElement(\"canvas\", _this.id);\n\n      _this._container.appendChild(_this._canvas);\n\n      document.body.appendChild(_this._container);\n      _existed = false;\n    } else if (_selector.nodeName.toLowerCase() != \"canvas\") {\n      _this._container = _selector;\n      _this._canvas = _this._createElement(\"canvas\", _this.id + \"_canvas\");\n\n      _this._container.appendChild(_this._canvas);\n\n      _this._initialResize = true;\n    } else {\n      _this._canvas = _selector;\n      _this._container = _selector.parentElement;\n      _this._autoResize = false;\n    }\n\n    setTimeout(_this._ready.bind(_assertThisInitialized(_assertThisInitialized(_this)), callback), 100);\n    _this._ctx = _this._canvas.getContext('2d');\n    return _this;\n  }\n\n  _createClass(CanvasSpace, [{\n    key: \"_createElement\",\n    value: function _createElement() {\n      var elem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"div\";\n      var id = arguments.length > 1 ? arguments[1] : undefined;\n      var d = document.createElement(elem);\n      d.setAttribute(\"id\", id);\n      return d;\n    }\n  }, {\n    key: \"_ready\",\n    value: function _ready(callback) {\n      if (!this._container) throw new Error(\"Cannot initiate #\".concat(this.id, \" element\"));\n      this._isReady = true;\n\n      this._resizeHandler(null);\n\n      this.clear(this._bgcolor);\n\n      this._canvas.dispatchEvent(new Event(\"ready\"));\n\n      for (var k in this.players) {\n        if (this.players.hasOwnProperty(k)) {\n          if (this.players[k].start) this.players[k].start(this.bound.clone(), this);\n        }\n      }\n\n      this._pointer = this.center;\n      this._initialResize = false;\n      if (callback) callback(this.bound, this._canvas);\n    }\n  }, {\n    key: \"setup\",\n    value: function setup(opt) {\n      if (opt.bgcolor) this._bgcolor = opt.bgcolor;\n      this.autoResize = opt.resize != undefined ? opt.resize : false;\n\n      if (opt.retina !== false) {\n        var r1 = window.devicePixelRatio || 1;\n        var r2 = this._ctx.webkitBackingStorePixelRatio || this._ctx.mozBackingStorePixelRatio || this._ctx.msBackingStorePixelRatio || this._ctx.oBackingStorePixelRatio || this._ctx.backingStorePixelRatio || 1;\n        this._pixelScale = Math.max(1, r1 / r2);\n      }\n\n      if (opt.offscreen) {\n        this._offscreen = true;\n        this._offCanvas = this._createElement(\"canvas\", this.id + \"_offscreen\");\n        this._offCtx = this._offCanvas.getContext('2d');\n      } else {\n        this._offscreen = false;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(b, evt) {\n      this.bound = b;\n      this._canvas.width = this.bound.size.x * this._pixelScale;\n      this._canvas.height = this.bound.size.y * this._pixelScale;\n      this._canvas.style.width = Math.floor(this.bound.size.x) + \"px\";\n      this._canvas.style.height = Math.floor(this.bound.size.y) + \"px\";\n\n      if (this._offscreen) {\n        this._offCanvas.width = this.bound.size.x * this._pixelScale;\n        this._offCanvas.height = this.bound.size.y * this._pixelScale;\n      }\n\n      if (this._pixelScale != 1) {\n        this._ctx.scale(this._pixelScale, this._pixelScale);\n\n        this._ctx.translate(0.5, 0.5);\n\n        if (this._offscreen) {\n          this._offCtx.scale(this._pixelScale, this._pixelScale);\n\n          this._offCtx.translate(0.5, 0.5);\n        }\n      }\n\n      for (var k in this.players) {\n        if (this.players.hasOwnProperty(k)) {\n          var p = this.players[k];\n          if (p.resize) p.resize(this.bound, evt);\n        }\n      }\n\n      this.render(this._ctx);\n      if (evt && !this.isPlaying) this.playOnce(0);\n      return this;\n    }\n  }, {\n    key: \"_resizeHandler\",\n    value: function _resizeHandler(evt) {\n      var b = this._autoResize || this._initialResize ? this._container.getBoundingClientRect() : this._canvas.getBoundingClientRect();\n\n      if (b) {\n        var box = Bound.fromBoundingRect(b);\n        box.center = box.center.add(window.pageXOffset, window.pageYOffset);\n        this.resize(box, evt);\n      }\n    }\n  }, {\n    key: \"getForm\",\n    value: function getForm() {\n      return new CanvasForm(this);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(bg) {\n      if (bg) this._bgcolor = bg;\n      var lastColor = this._ctx.fillStyle;\n\n      if (this._bgcolor && this._bgcolor != \"transparent\") {\n        this._ctx.fillStyle = this._bgcolor;\n\n        this._ctx.fillRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n      } else {\n        this._ctx.clearRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n      }\n\n      this._ctx.fillStyle = lastColor;\n      return this;\n    }\n  }, {\n    key: \"clearOffscreen\",\n    value: function clearOffscreen(bg) {\n      if (this._offscreen) {\n        if (bg) {\n          this._offCtx.fillStyle = bg;\n\n          this._offCtx.fillRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n        } else {\n          this._offCtx.clearRect(-1, -1, this._offCanvas.width + 1, this._offCanvas.height + 1);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"playItems\",\n    value: function playItems(time) {\n      if (this._isReady) {\n        this._ctx.save();\n\n        if (this._offscreen) this._offCtx.save();\n\n        _get(_getPrototypeOf(CanvasSpace.prototype), \"playItems\", this).call(this, time);\n\n        this._ctx.restore();\n\n        if (this._offscreen) this._offCtx.restore();\n        this.render(this._ctx);\n      }\n    }\n  }, {\n    key: \"autoResize\",\n    set: function set(auto) {\n      this._autoResize = auto;\n\n      if (auto) {\n        window.addEventListener('resize', this._resizeHandler.bind(this));\n      } else {\n        window.removeEventListener('resize', this._resizeHandler.bind(this));\n      }\n    },\n    get: function get() {\n      return this._autoResize;\n    }\n  }, {\n    key: \"background\",\n    set: function set(bg) {\n      this._bgcolor = bg;\n    },\n    get: function get() {\n      return this._bgcolor;\n    }\n  }, {\n    key: \"pixelScale\",\n    get: function get() {\n      return this._pixelScale;\n    }\n  }, {\n    key: \"hasOffscreen\",\n    get: function get() {\n      return this._offscreen;\n    }\n  }, {\n    key: \"offscreenCtx\",\n    get: function get() {\n      return this._offCtx;\n    }\n  }, {\n    key: \"offscreenCanvas\",\n    get: function get() {\n      return this._offCanvas;\n    }\n  }, {\n    key: \"element\",\n    get: function get() {\n      return this._canvas;\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._container;\n    }\n  }, {\n    key: \"ready\",\n    get: function get() {\n      return this._isReady;\n    }\n  }, {\n    key: \"ctx\",\n    get: function get() {\n      return this._ctx;\n    }\n  }]);\n\n  return CanvasSpace;\n}(MultiTouchSpace);\nexport var CanvasForm =\n/*#__PURE__*/\nfunction (_VisualForm) {\n  _inherits(CanvasForm, _VisualForm);\n\n  function CanvasForm(space) {\n    var _this2;\n\n    _classCallCheck(this, CanvasForm);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(CanvasForm).call(this));\n    _this2._style = {\n      fillStyle: \"#f03\",\n      strokeStyle: \"#fff\",\n      lineWidth: 1,\n      lineJoin: \"bevel\",\n      lineCap: \"butt\"\n    };\n    _this2._space = space;\n\n    _this2._space.add({\n      start: function start() {\n        _this2._ctx = _this2._space.ctx;\n        _this2._ctx.fillStyle = _this2._style.fillStyle;\n        _this2._ctx.strokeStyle = _this2._style.strokeStyle;\n        _this2._ctx.lineJoin = \"bevel\";\n        _this2._ctx.font = _this2._font.value;\n        _this2._ready = true;\n      }\n    });\n\n    return _this2;\n  }\n\n  _createClass(CanvasForm, [{\n    key: \"useOffscreen\",\n    value: function useOffscreen() {\n      var off = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var clear = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (clear) this._space.clearOffscreen(typeof clear == \"string\" ? clear : null);\n      this._ctx = this._space.hasOffscreen && off ? this._space.offscreenCtx : this._space.ctx;\n      return this;\n    }\n  }, {\n    key: \"renderOffscreen\",\n    value: function renderOffscreen() {\n      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0];\n\n      if (this._space.hasOffscreen) {\n        this._space.ctx.drawImage(this._space.offscreenCanvas, offset[0], offset[1], this._space.width, this._space.height);\n      }\n    }\n  }, {\n    key: \"fill\",\n    value: function fill(c) {\n      if (typeof c == \"boolean\") {\n        this.filled = c;\n      } else {\n        this.filled = true;\n        this._style.fillStyle = c;\n        this._ctx.fillStyle = c;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"stroke\",\n    value: function stroke(c, width, linejoin, linecap) {\n      if (typeof c == \"boolean\") {\n        this.stroked = c;\n      } else {\n        this.stroked = true;\n        this._style.strokeStyle = c;\n        this._ctx.strokeStyle = c;\n\n        if (width) {\n          this._ctx.lineWidth = width;\n          this._style.lineWidth = width;\n        }\n\n        if (linejoin) {\n          this._ctx.lineJoin = linejoin;\n          this._style.lineJoin = linejoin;\n        }\n\n        if (linecap) {\n          this._ctx.lineCap = linecap;\n          this._style.lineCap = linecap;\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"font\",\n    value: function font(sizeOrFont, weight, style, lineHeight, family) {\n      if (typeof sizeOrFont == \"number\") {\n        this._font.size = sizeOrFont;\n        if (family) this._font.face = family;\n        if (weight) this._font.weight = weight;\n        if (style) this._font.style = style;\n        if (lineHeight) this._font.lineHeight = lineHeight;\n      } else {\n        this._font = sizeOrFont;\n      }\n\n      this._ctx.font = this._font.value;\n      if (this._estimateTextWidth) this.fontWidthEstimate(true);\n      return this;\n    }\n  }, {\n    key: \"fontWidthEstimate\",\n    value: function fontWidthEstimate() {\n      var _this3 = this;\n\n      var estimate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this._estimateTextWidth = estimate ? Typo.textWidthEstimator(function (c) {\n        return _this3._ctx.measureText(c).width;\n      }) : undefined;\n      return this;\n    }\n  }, {\n    key: \"getTextWidth\",\n    value: function getTextWidth(c) {\n      return !this._estimateTextWidth ? this._ctx.measureText(c + \" .\").width : this._estimateTextWidth(c);\n    }\n  }, {\n    key: \"_textTruncate\",\n    value: function _textTruncate(str, width) {\n      var tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n      return Typo.truncate(this.getTextWidth.bind(this), str, width, tail);\n    }\n  }, {\n    key: \"_textAlign\",\n    value: function _textAlign(box, vertical, offset, center) {\n      if (!center) center = Rectangle.center(box);\n      var px = box[0][0];\n\n      if (this._ctx.textAlign == \"end\" || this._ctx.textAlign == \"right\") {\n        px = box[1][0];\n      } else if (this._ctx.textAlign == \"center\" || this._ctx.textAlign == \"middle\") {\n        px = center[0];\n      }\n\n      var py = center[1];\n\n      if (vertical == \"top\" || vertical == \"start\") {\n        py = box[0][1];\n      } else if (vertical == \"end\" || vertical == \"bottom\") {\n        py = box[1][1];\n      }\n\n      return offset ? new Pt(px + offset[0], py + offset[1]) : new Pt(px, py);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      for (var k in this._style) {\n        if (this._style.hasOwnProperty(k)) {\n          this._ctx[k] = this._style[k];\n        }\n      }\n\n      this._font = new Font();\n      this._ctx.font = this._font.value;\n      return this;\n    }\n  }, {\n    key: \"_paint\",\n    value: function _paint() {\n      if (this._filled) this._ctx.fill();\n      if (this._stroked) this._ctx.stroke();\n    }\n  }, {\n    key: \"point\",\n    value: function point(p) {\n      var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n      var shape = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"square\";\n      if (!p) return;\n      if (!CanvasForm[shape]) throw new Error(\"\".concat(shape, \" is not a static function of CanvasForm\"));\n      CanvasForm[shape](this._ctx, p, radius);\n\n      this._paint();\n\n      return this;\n    }\n  }, {\n    key: \"circle\",\n    value: function circle(pts) {\n      CanvasForm.circle(this._ctx, pts[0], pts[1][0]);\n\n      this._paint();\n\n      return this;\n    }\n  }, {\n    key: \"arc\",\n    value: function arc(pt, radius, startAngle, endAngle, cc) {\n      CanvasForm.arc(this._ctx, pt, radius, startAngle, endAngle, cc);\n\n      this._paint();\n\n      return this;\n    }\n  }, {\n    key: \"square\",\n    value: function square(pt, halfsize) {\n      CanvasForm.square(this._ctx, pt, halfsize);\n\n      this._paint();\n\n      return this;\n    }\n  }, {\n    key: \"line\",\n    value: function line(pts) {\n      CanvasForm.line(this._ctx, pts);\n\n      this._paint();\n\n      return this;\n    }\n  }, {\n    key: \"polygon\",\n    value: function polygon(pts) {\n      CanvasForm.polygon(this._ctx, pts);\n\n      this._paint();\n\n      return this;\n    }\n  }, {\n    key: \"rect\",\n    value: function rect(pts) {\n      CanvasForm.rect(this._ctx, pts);\n\n      this._paint();\n\n      return this;\n    }\n  }, {\n    key: \"image\",\n    value: function image(img, target, original) {\n      CanvasForm.image(this._ctx, img, target, original);\n      return this;\n    }\n  }, {\n    key: \"text\",\n    value: function text(pt, txt, maxWidth) {\n      CanvasForm.text(this._ctx, pt, txt, maxWidth);\n      return this;\n    }\n  }, {\n    key: \"textBox\",\n    value: function textBox(box, txt) {\n      var verticalAlign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"middle\";\n      var tail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n      var overrideBaseline = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n      if (overrideBaseline) this._ctx.textBaseline = verticalAlign;\n      var size = Rectangle.size(box);\n\n      var t = this._textTruncate(txt, size[0], tail);\n\n      this.text(this._textAlign(box, verticalAlign), t[0]);\n      return this;\n    }\n  }, {\n    key: \"paragraphBox\",\n    value: function paragraphBox(box, txt) {\n      var _this4 = this;\n\n      var lineHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.2;\n      var verticalAlign = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"top\";\n      var crop = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n      var size = Rectangle.size(box);\n      this._ctx.textBaseline = \"top\";\n      var lstep = this._font.size * lineHeight;\n\n      var nextLine = function nextLine(sub) {\n        var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        var cc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        if (!sub) return buffer;\n        if (crop && cc * lstep > size[1] - lstep * 2) return buffer;\n        if (cc > 10000) throw new Error(\"max recursion reached (10000)\");\n\n        var t = _this4._textTruncate(sub, size[0], \"\");\n\n        var newln = t[0].indexOf(\"\\n\");\n\n        if (newln >= 0) {\n          buffer.push(t[0].substr(0, newln));\n          return nextLine(sub.substr(newln + 1), buffer, cc + 1);\n        }\n\n        var dt = t[0].lastIndexOf(\" \") + 1;\n        if (dt <= 0 || t[1] === sub.length) dt = undefined;\n        var line = t[0].substr(0, dt);\n        buffer.push(line);\n        return t[1] <= 0 || t[1] === sub.length ? buffer : nextLine(sub.substr(dt || t[1]), buffer, cc + 1);\n      };\n\n      var lines = nextLine(txt);\n      var lsize = lines.length * lstep;\n      var lbox = box;\n\n      if (verticalAlign == \"middle\" || verticalAlign == \"center\") {\n        var lpad = (size[1] - lsize) / 2;\n        if (crop) lpad = Math.max(0, lpad);\n        lbox = new Group(box[0].$add(0, lpad), box[1].$subtract(0, lpad));\n      } else if (verticalAlign == \"bottom\") {\n        lbox = new Group(box[0].$add(0, size[1] - lsize), box[1]);\n      } else {\n        lbox = new Group(box[0], box[0].$add(size[0], lsize));\n      }\n\n      var center = Rectangle.center(lbox);\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        this.text(this._textAlign(lbox, \"top\", [0, i * lstep], center), lines[i]);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"alignText\",\n    value: function alignText() {\n      var alignment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"left\";\n      var baseline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"alphabetic\";\n      if (baseline == \"center\") baseline = \"middle\";\n      if (baseline == \"baseline\") baseline = \"alphabetic\";\n      this._ctx.textAlign = alignment;\n      this._ctx.textBaseline = baseline;\n      return this;\n    }\n  }, {\n    key: \"log\",\n    value: function log(txt) {\n      var w = this._ctx.measureText(txt).width + 20;\n      this.stroke(false).fill(\"rgba(0,0,0,.4)\").rect([[0, 0], [w, 20]]);\n      this.fill(\"#fff\").text([10, 14], txt);\n      return this;\n    }\n  }, {\n    key: \"space\",\n    get: function get() {\n      return this._space;\n    }\n  }], [{\n    key: \"circle\",\n    value: function circle(ctx, pt) {\n      var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n      if (!pt) return;\n      ctx.beginPath();\n      ctx.arc(pt[0], pt[1], radius, 0, Const.two_pi, false);\n      ctx.closePath();\n    }\n  }, {\n    key: \"arc\",\n    value: function arc(ctx, pt, radius, startAngle, endAngle, cc) {\n      if (!pt) return;\n      ctx.beginPath();\n      ctx.arc(pt[0], pt[1], radius, startAngle, endAngle, cc);\n    }\n  }, {\n    key: \"square\",\n    value: function square(ctx, pt, halfsize) {\n      if (!pt) return;\n      var x1 = pt[0] - halfsize;\n      var y1 = pt[1] - halfsize;\n      var x2 = pt[0] + halfsize;\n      var y2 = pt[1] + halfsize;\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x1, y2);\n      ctx.lineTo(x2, y2);\n      ctx.lineTo(x2, y1);\n      ctx.closePath();\n    }\n  }, {\n    key: \"line\",\n    value: function line(ctx, pts) {\n      if (pts.length < 2) return;\n      ctx.beginPath();\n      ctx.moveTo(pts[0][0], pts[0][1]);\n\n      for (var i = 1, len = pts.length; i < len; i++) {\n        if (pts[i]) ctx.lineTo(pts[i][0], pts[i][1]);\n      }\n    }\n  }, {\n    key: \"polygon\",\n    value: function polygon(ctx, pts) {\n      if (pts.length < 2) return;\n      ctx.beginPath();\n      ctx.moveTo(pts[0][0], pts[0][1]);\n\n      for (var i = 1, len = pts.length; i < len; i++) {\n        if (pts[i]) ctx.lineTo(pts[i][0], pts[i][1]);\n      }\n\n      ctx.closePath();\n    }\n  }, {\n    key: \"rect\",\n    value: function rect(ctx, pts) {\n      if (pts.length < 2) return;\n      ctx.beginPath();\n      ctx.moveTo(pts[0][0], pts[0][1]);\n      ctx.lineTo(pts[0][0], pts[1][1]);\n      ctx.lineTo(pts[1][0], pts[1][1]);\n      ctx.lineTo(pts[1][0], pts[0][1]);\n      ctx.closePath();\n    }\n  }, {\n    key: \"image\",\n    value: function image(ctx, img) {\n      var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Pt();\n      var orig = arguments.length > 3 ? arguments[3] : undefined;\n\n      if (typeof target[0] === \"number\") {\n        ctx.drawImage(img, target[0], target[1]);\n      } else {\n        var t = target;\n\n        if (orig) {\n          ctx.drawImage(img, orig[0][0], orig[0][1], orig[1][0] - orig[0][0], orig[1][1] - orig[0][1], t[0][0], t[0][1], t[1][0] - t[0][0], t[1][1] - t[0][1]);\n        } else {\n          ctx.drawImage(img, t[0][0], t[0][1], t[1][0] - t[0][0], t[1][1] - t[0][1]);\n        }\n      }\n    }\n  }, {\n    key: \"text\",\n    value: function text(ctx, pt, txt, maxWidth) {\n      if (!pt) return;\n      ctx.fillText(txt, pt[0], pt[1], maxWidth);\n    }\n  }]);\n\n  return CanvasForm;\n}(VisualForm);","map":null,"metadata":{},"sourceType":"module"}