{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/*! Source code licensed under Apache License 2.0. Copyright Â© 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Const } from \"./Util\";\nimport { Curve } from \"./Op\";\nimport { Pt, Group } from \"./Pt\";\nimport { Vec, Mat } from \"./LinearAlgebra\";\nexport var Num =\n/*#__PURE__*/\nfunction () {\n  function Num() {\n    _classCallCheck(this, Num);\n  }\n\n  _createClass(Num, null, [{\n    key: \"equals\",\n    value: function equals(a, b) {\n      var threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.00001;\n      return Math.abs(a - b) < threshold;\n    }\n  }, {\n    key: \"lerp\",\n    value: function lerp(a, b, t) {\n      return (1 - t) * a + t * b;\n    }\n  }, {\n    key: \"clamp\",\n    value: function clamp(val, min, max) {\n      return Math.max(min, Math.min(max, val));\n    }\n  }, {\n    key: \"boundValue\",\n    value: function boundValue(val, min, max) {\n      var len = Math.abs(max - min);\n      var a = val % len;\n      if (a > max) a -= len;else if (a < min) a += len;\n      return a;\n    }\n  }, {\n    key: \"within\",\n    value: function within(p, a, b) {\n      return p >= Math.min(a, b) && p <= Math.max(a, b);\n    }\n  }, {\n    key: \"randomRange\",\n    value: function randomRange(a) {\n      var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var r = a > b ? a - b : b - a;\n      return a + Math.random() * r;\n    }\n  }, {\n    key: \"normalizeValue\",\n    value: function normalizeValue(n, a, b) {\n      var min = Math.min(a, b);\n      var max = Math.max(a, b);\n      return (n - min) / (max - min);\n    }\n  }, {\n    key: \"sum\",\n    value: function sum(pts) {\n      var c = new Pt(pts[0]);\n\n      for (var i = 1, len = pts.length; i < len; i++) {\n        Vec.add(c, pts[i]);\n      }\n\n      return c;\n    }\n  }, {\n    key: \"average\",\n    value: function average(pts) {\n      return Num.sum(pts).divide(pts.length);\n    }\n  }, {\n    key: \"cycle\",\n    value: function cycle(t) {\n      return (Math.sin(Math.PI * 2 * t) + 1) / 2;\n    }\n  }, {\n    key: \"mapToRange\",\n    value: function mapToRange(n, currA, currB, targetA, targetB) {\n      if (currA == currB) throw new Error(\"[currMin, currMax] must define a range that is not zero\");\n      var min = Math.min(targetA, targetB);\n      var max = Math.max(targetA, targetB);\n      return Num.normalizeValue(n, currA, currB) * (max - min) + min;\n    }\n  }]);\n\n  return Num;\n}();\nexport var Geom =\n/*#__PURE__*/\nfunction () {\n  function Geom() {\n    _classCallCheck(this, Geom);\n  }\n\n  _createClass(Geom, null, [{\n    key: \"boundAngle\",\n    value: function boundAngle(angle) {\n      return Num.boundValue(angle, 0, 360);\n    }\n  }, {\n    key: \"boundRadian\",\n    value: function boundRadian(radian) {\n      return Num.boundValue(radian, 0, Const.two_pi);\n    }\n  }, {\n    key: \"toRadian\",\n    value: function toRadian(angle) {\n      return angle * Const.deg_to_rad;\n    }\n  }, {\n    key: \"toDegree\",\n    value: function toDegree(radian) {\n      return radian * Const.rad_to_deg;\n    }\n  }, {\n    key: \"boundingBox\",\n    value: function boundingBox(pts) {\n      var minPt = pts.reduce(function (a, p) {\n        return a.$min(p);\n      });\n      var maxPt = pts.reduce(function (a, p) {\n        return a.$max(p);\n      });\n      return new Group(minPt, maxPt);\n    }\n  }, {\n    key: \"centroid\",\n    value: function centroid(pts) {\n      return Num.average(pts);\n    }\n  }, {\n    key: \"anchor\",\n    value: function anchor(pts) {\n      var ptOrIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"to\";\n      var method = direction == \"to\" ? \"subtract\" : \"add\";\n\n      for (var i = 0, len = pts.length; i < len; i++) {\n        if (typeof ptOrIndex == \"number\") {\n          if (ptOrIndex !== i) pts[i][method](pts[ptOrIndex]);\n        } else {\n          pts[i][method](ptOrIndex);\n        }\n      }\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate(a, b) {\n      var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;\n      var len = Math.min(a.length, b.length);\n      var d = Pt.make(len);\n\n      for (var i = 0; i < len; i++) {\n        d[i] = a[i] * (1 - t) + b[i] * t;\n      }\n\n      return d;\n    }\n  }, {\n    key: \"perpendicular\",\n    value: function perpendicular(pt) {\n      var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Const.xy;\n      var y = axis[1];\n      var x = axis[0];\n      var p = new Pt(pt);\n      var pa = new Pt(p);\n      pa[x] = -p[y];\n      pa[y] = p[x];\n      var pb = new Pt(p);\n      pb[x] = p[y];\n      pb[y] = -p[x];\n      return new Group(pa, pb);\n    }\n  }, {\n    key: \"isPerpendicular\",\n    value: function isPerpendicular(p1, p2) {\n      return new Pt(p1).dot(p2) === 0;\n    }\n  }, {\n    key: \"withinBound\",\n    value: function withinBound(pt, boundPt1, boundPt2) {\n      for (var i = 0, len = Math.min(pt.length, boundPt1.length, boundPt2.length); i < len; i++) {\n        if (!Num.within(pt[i], boundPt1[i], boundPt2[i])) return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"sortEdges\",\n    value: function sortEdges(pts) {\n      var bounds = Geom.boundingBox(pts);\n      var center = bounds[1].add(bounds[0]).divide(2);\n\n      var fn = function fn(a, b) {\n        if (a.length < 2 || b.length < 2) throw new Error(\"Pt dimension cannot be less than 2\");\n        var da = a.$subtract(center);\n        var db = b.$subtract(center);\n        if (da[0] >= 0 && db[0] < 0) return 1;\n        if (da[0] < 0 && db[0] >= 0) return -1;\n\n        if (da[0] == 0 && db[0] == 0) {\n          if (da[1] >= 0 || db[1] >= 0) return da[1] > db[1] ? 1 : -1;\n          return db[1] > da[1] ? 1 : -1;\n        }\n\n        var det = da.$cross2D(db);\n        if (det < 0) return 1;\n        if (det > 0) return -1;\n        return da[0] * da[0] + da[1] * da[1] > db[0] * db[0] + db[1] * db[1] ? 1 : -1;\n      };\n\n      return pts.sort(fn);\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(ps, _scale, anchor) {\n      var pts = !Array.isArray(ps) ? [ps] : ps;\n      var scs = typeof _scale == \"number\" ? Pt.make(pts[0].length, _scale) : _scale;\n      if (!anchor) anchor = Pt.make(pts[0].length, 0);\n\n      for (var i = 0, len = pts.length; i < len; i++) {\n        var p = pts[i];\n\n        for (var k = 0, lenP = p.length; k < lenP; k++) {\n          p[k] = anchor && anchor[k] ? anchor[k] + (p[k] - anchor[k]) * scs[k] : p[k] * scs[k];\n        }\n      }\n\n      return Geom;\n    }\n  }, {\n    key: \"rotate2D\",\n    value: function rotate2D(ps, angle, anchor, axis) {\n      var pts = !Array.isArray(ps) ? [ps] : ps;\n      var fn = anchor ? Mat.rotateAt2DMatrix : Mat.rotate2DMatrix;\n      if (!anchor) anchor = Pt.make(pts[0].length, 0);\n      var cos = Math.cos(angle);\n      var sin = Math.sin(angle);\n\n      for (var i = 0, len = pts.length; i < len; i++) {\n        var p = axis ? pts[i].$take(axis) : pts[i];\n        p.to(Mat.transform2D(p, fn(cos, sin, anchor)));\n      }\n\n      return Geom;\n    }\n  }, {\n    key: \"shear2D\",\n    value: function shear2D(ps, scale, anchor, axis) {\n      var pts = !Array.isArray(ps) ? [ps] : ps;\n      var s = typeof scale == \"number\" ? [scale, scale] : scale;\n      if (!anchor) anchor = Pt.make(pts[0].length, 0);\n      var fn = anchor ? Mat.shearAt2DMatrix : Mat.shear2DMatrix;\n      var tanx = Math.tan(s[0]);\n      var tany = Math.tan(s[1]);\n\n      for (var i = 0, len = pts.length; i < len; i++) {\n        var p = axis ? pts[i].$take(axis) : pts[i];\n        p.to(Mat.transform2D(p, fn(tanx, tany, anchor)));\n      }\n\n      return Geom;\n    }\n  }, {\n    key: \"reflect2D\",\n    value: function reflect2D(ps, line, axis) {\n      var pts = !Array.isArray(ps) ? [ps] : ps;\n      var mat = Mat.reflectAt2DMatrix(line[0], line[1]);\n\n      for (var i = 0, len = pts.length; i < len; i++) {\n        var p = axis ? pts[i].$take(axis) : pts[i];\n        p.to(Mat.transform2D(p, mat));\n      }\n\n      return Geom;\n    }\n  }, {\n    key: \"cosTable\",\n    value: function cosTable() {\n      var cos = new Float64Array(360);\n\n      for (var i = 0; i < 360; i++) {\n        cos[i] = Math.cos(i * Math.PI / 180);\n      }\n\n      var find = function find(rad) {\n        return cos[Math.floor(Geom.boundAngle(Geom.toDegree(rad)))];\n      };\n\n      return {\n        table: cos,\n        cos: find\n      };\n    }\n  }, {\n    key: \"sinTable\",\n    value: function sinTable() {\n      var sin = new Float64Array(360);\n\n      for (var i = 0; i < 360; i++) {\n        sin[i] = Math.sin(i * Math.PI / 180);\n      }\n\n      var find = function find(rad) {\n        return sin[Math.floor(Geom.boundAngle(Geom.toDegree(rad)))];\n      };\n\n      return {\n        table: sin,\n        sin: find\n      };\n    }\n  }]);\n\n  return Geom;\n}();\nexport var Shaping =\n/*#__PURE__*/\nfunction () {\n  function Shaping() {\n    _classCallCheck(this, Shaping);\n  }\n\n  _createClass(Shaping, null, [{\n    key: \"linear\",\n    value: function linear(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return c * t;\n    }\n  }, {\n    key: \"quadraticIn\",\n    value: function quadraticIn(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return c * t * t;\n    }\n  }, {\n    key: \"quadraticOut\",\n    value: function quadraticOut(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return -c * t * (t - 2);\n    }\n  }, {\n    key: \"quadraticInOut\",\n    value: function quadraticInOut(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var dt = t * 2;\n      return t < 0.5 ? c / 2 * t * t * 4 : -c / 2 * ((dt - 1) * (dt - 3) - 1);\n    }\n  }, {\n    key: \"cubicIn\",\n    value: function cubicIn(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return c * t * t * t;\n    }\n  }, {\n    key: \"cubicOut\",\n    value: function cubicOut(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var dt = t - 1;\n      return c * (dt * dt * dt + 1);\n    }\n  }, {\n    key: \"cubicInOut\",\n    value: function cubicInOut(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var dt = t * 2;\n      return t < 0.5 ? c / 2 * dt * dt * dt : c / 2 * ((dt - 2) * (dt - 2) * (dt - 2) + 2);\n    }\n  }, {\n    key: \"exponentialIn\",\n    value: function exponentialIn(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.25;\n      return c * Math.pow(t, 1 / p);\n    }\n  }, {\n    key: \"exponentialOut\",\n    value: function exponentialOut(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.25;\n      return c * Math.pow(t, p);\n    }\n  }, {\n    key: \"sineIn\",\n    value: function sineIn(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return -c * Math.cos(t * Const.half_pi) + c;\n    }\n  }, {\n    key: \"sineOut\",\n    value: function sineOut(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return c * Math.sin(t * Const.half_pi);\n    }\n  }, {\n    key: \"sineInOut\",\n    value: function sineInOut(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return -c / 2 * (Math.cos(Math.PI * t) - 1);\n    }\n  }, {\n    key: \"cosineApprox\",\n    value: function cosineApprox(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var t2 = t * t;\n      var t4 = t2 * t2;\n      var t6 = t4 * t2;\n      return c * (4 * t6 / 9 - 17 * t4 / 9 + 22 * t2 / 9);\n    }\n  }, {\n    key: \"circularIn\",\n    value: function circularIn(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return -c * (Math.sqrt(1 - t * t) - 1);\n    }\n  }, {\n    key: \"circularOut\",\n    value: function circularOut(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var dt = t - 1;\n      return c * Math.sqrt(1 - dt * dt);\n    }\n  }, {\n    key: \"circularInOut\",\n    value: function circularInOut(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var dt = t * 2;\n      return t < 0.5 ? -c / 2 * (Math.sqrt(1 - dt * dt) - 1) : c / 2 * (Math.sqrt(1 - (dt - 2) * (dt - 2)) + 1);\n    }\n  }, {\n    key: \"elasticIn\",\n    value: function elasticIn(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.7;\n      var dt = t - 1;\n      var s = p / Const.two_pi * 1.5707963267948966;\n      return c * (-Math.pow(2, 10 * dt) * Math.sin((dt - s) * Const.two_pi / p));\n    }\n  }, {\n    key: \"elasticOut\",\n    value: function elasticOut(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.7;\n      var s = p / Const.two_pi * 1.5707963267948966;\n      return c * (Math.pow(2, -10 * t) * Math.sin((t - s) * Const.two_pi / p)) + c;\n    }\n  }, {\n    key: \"elasticInOut\",\n    value: function elasticInOut(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.6;\n      var dt = t * 2;\n      var s = p / Const.two_pi * 1.5707963267948966;\n\n      if (t < 0.5) {\n        dt -= 1;\n        return c * (-0.5 * (Math.pow(2, 10 * dt) * Math.sin((dt - s) * Const.two_pi / p)));\n      } else {\n        dt -= 1;\n        return c * (0.5 * (Math.pow(2, -10 * dt) * Math.sin((dt - s) * Const.two_pi / p))) + c;\n      }\n    }\n  }, {\n    key: \"bounceIn\",\n    value: function bounceIn(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return c - Shaping.bounceOut(1 - t, c);\n    }\n  }, {\n    key: \"bounceOut\",\n    value: function bounceOut(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      if (t < 1 / 2.75) {\n        return c * (7.5625 * t * t);\n      } else if (t < 2 / 2.75) {\n        t -= 1.5 / 2.75;\n        return c * (7.5625 * t * t + 0.75);\n      } else if (t < 2.5 / 2.75) {\n        t -= 2.25 / 2.75;\n        return c * (7.5625 * t * t + 0.9375);\n      } else {\n        t -= 2.625 / 2.75;\n        return c * (7.5625 * t * t + 0.984375);\n      }\n    }\n  }, {\n    key: \"bounceInOut\",\n    value: function bounceInOut(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return t < 0.5 ? Shaping.bounceIn(t * 2, c) / 2 : Shaping.bounceOut(t * 2 - 1, c) / 2 + c / 2;\n    }\n  }, {\n    key: \"sigmoid\",\n    value: function sigmoid(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n      var d = p * (t - 0.5);\n      return c / (1 + Math.exp(-d));\n    }\n  }, {\n    key: \"logSigmoid\",\n    value: function logSigmoid(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.7;\n      p = Math.max(Const.epsilon, Math.min(1 - Const.epsilon, p));\n      p = 1 / (1 - p);\n      var A = 1 / (1 + Math.exp((t - 0.5) * p * -2));\n      var B = 1 / (1 + Math.exp(p));\n      var C = 1 / (1 + Math.exp(-p));\n      return c * (A - B) / (C - B);\n    }\n  }, {\n    key: \"seat\",\n    value: function seat(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;\n\n      if (t < 0.5) {\n        return c * Math.pow(2 * t, 1 - p) / 2;\n      } else {\n        return c * (1 - Math.pow(2 * (1 - t), 1 - p) / 2);\n      }\n    }\n  }, {\n    key: \"quadraticBezier\",\n    value: function quadraticBezier(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0.05, 0.95];\n      var a = typeof p != \"number\" ? p[0] : p;\n      var b = typeof p != \"number\" ? p[1] : 0.5;\n      var om2a = 1 - 2 * a;\n\n      if (om2a === 0) {\n        om2a = Const.epsilon;\n      }\n\n      var d = (Math.sqrt(a * a + om2a * t) - a) / om2a;\n      return c * ((1 - 2 * b) * (d * d) + 2 * b * d);\n    }\n  }, {\n    key: \"cubicBezier\",\n    value: function cubicBezier(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var p1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0.1, 0.7];\n      var p2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0.9, 0.2];\n      var curve = new Group(new Pt(0, 0), new Pt(p1), new Pt(p2), new Pt(1, 1));\n      return c * Curve.bezierStep(new Pt(t * t * t, t * t, t, 1), Curve.controlPoints(curve)).y;\n    }\n  }, {\n    key: \"quadraticTarget\",\n    value: function quadraticTarget(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var p1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0.2, 0.35];\n      var a = Math.min(1 - Const.epsilon, Math.max(Const.epsilon, p1[0]));\n      var b = Math.min(1, Math.max(0, p1[1]));\n      var A = (1 - b) / (1 - a) - b / a;\n      var B = (A * (a * a) - b) / a;\n      var y = A * (t * t) - B * t;\n      return c * Math.min(1, Math.max(0, y));\n    }\n  }, {\n    key: \"cliff\",\n    value: function cliff(t) {\n      var c = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;\n      return t > p ? c : 0;\n    }\n  }, {\n    key: \"step\",\n    value: function step(fn, steps, t, c) {\n      var s = 1 / steps;\n      var tt = Math.floor(t / s) * s;\n\n      for (var _len = arguments.length, args = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {\n        args[_key - 4] = arguments[_key];\n      }\n\n      return fn.apply(void 0, [tt, c].concat(args));\n    }\n  }]);\n\n  return Shaping;\n}();\nexport var Range =\n/*#__PURE__*/\nfunction () {\n  function Range(g) {\n    _classCallCheck(this, Range);\n\n    this._dims = 0;\n    this._source = Group.fromPtArray(g);\n    this.calc();\n  }\n\n  _createClass(Range, [{\n    key: \"calc\",\n    value: function calc() {\n      if (!this._source) return;\n      var dims = this._source[0].length;\n      this._dims = dims;\n      var max = new Pt(dims);\n      var min = new Pt(dims);\n      var mag = new Pt(dims);\n\n      for (var i = 0; i < dims; i++) {\n        max[i] = Const.min;\n        min[i] = Const.max;\n        mag[i] = 0;\n\n        var s = this._source.zipSlice(i);\n\n        for (var k = 0, len = s.length; k < len; k++) {\n          max[i] = Math.max(max[i], s[k]);\n          min[i] = Math.min(min[i], s[k]);\n          mag[i] = max[i] - min[i];\n        }\n      }\n\n      this._max = max;\n      this._min = min;\n      this._mag = mag;\n      return this;\n    }\n  }, {\n    key: \"mapTo\",\n    value: function mapTo(min, max, exclude) {\n      var target = new Group();\n\n      for (var i = 0, len = this._source.length; i < len; i++) {\n        var g = this._source[i];\n        var n = new Pt(this._dims);\n\n        for (var k = 0; k < this._dims; k++) {\n          n[k] = exclude && exclude[k] ? g[k] : Num.mapToRange(g[k], this._min[k], this._max[k], min, max);\n        }\n\n        target.push(n);\n      }\n\n      return target;\n    }\n  }, {\n    key: \"append\",\n    value: function append(g) {\n      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (g[0].length !== this._dims) throw new Error(\"Dimensions don't match. \".concat(this._dims, \" dimensions in Range and \").concat(g[0].length, \" provided in parameter. \"));\n      this._source = this._source.concat(g);\n      if (update) this.calc();\n      return this;\n    }\n  }, {\n    key: \"ticks\",\n    value: function ticks(count) {\n      var g = new Group();\n\n      for (var i = 0; i <= count; i++) {\n        var p = new Pt(this._dims);\n\n        for (var k = 0, len = this._max.length; k < len; k++) {\n          p[k] = Num.lerp(this._min[k], this._max[k], i / count);\n        }\n\n        g.push(p);\n      }\n\n      return g;\n    }\n  }, {\n    key: \"max\",\n    get: function get() {\n      return this._max.clone();\n    }\n  }, {\n    key: \"min\",\n    get: function get() {\n      return this._min.clone();\n    }\n  }, {\n    key: \"magnitude\",\n    get: function get() {\n      return this._mag.clone();\n    }\n  }]);\n\n  return Range;\n}();","map":null,"metadata":{},"sourceType":"module"}