{"ast":null,"code":"import _possibleConstructorReturn from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _classCallCheck from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/*! Source code licensed under Apache License 2.0. Copyright Â© 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Pt, Bound } from \"./Pt\";\nimport { UIPointerActions as UIA } from \"./UI\";\nexport var Space =\n/*#__PURE__*/\nfunction () {\n  function Space() {\n    _classCallCheck(this, Space);\n\n    this.id = \"space\";\n    this.bound = new Bound();\n    this._time = {\n      prev: 0,\n      diff: 0,\n      end: -1\n    };\n    this.players = {};\n    this.playerCount = 0;\n    this._animID = -1;\n    this._pause = false;\n    this._refresh = undefined;\n    this._pointer = new Pt();\n    this._isReady = false;\n    this._playing = false;\n  }\n\n  _createClass(Space, [{\n    key: \"refresh\",\n    value: function refresh(b) {\n      this._refresh = b;\n      return this;\n    }\n  }, {\n    key: \"add\",\n    value: function add(p) {\n      var player = typeof p == \"function\" ? {\n        animate: p\n      } : p;\n      var k = this.playerCount++;\n      var pid = this.id + k;\n      this.players[pid] = player;\n      player.animateID = pid;\n      if (player.resize && this.bound.inited) player.resize(this.bound);\n      if (this._refresh === undefined) this._refresh = true;\n      return this;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(player) {\n      delete this.players[player.animateID];\n      return this;\n    }\n  }, {\n    key: \"removeAll\",\n    value: function removeAll() {\n      this.players = {};\n      return this;\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      this._animID = requestAnimationFrame(this.play.bind(this));\n      if (this._pause) return this;\n      this._time.diff = time - this._time.prev;\n      this._time.prev = time;\n\n      try {\n        this.playItems(time);\n      } catch (err) {\n        cancelAnimationFrame(this._animID);\n        this._playing = false;\n        throw err;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"replay\",\n    value: function replay() {\n      this._time.end = -1;\n      this.play();\n    }\n  }, {\n    key: \"playItems\",\n    value: function playItems(time) {\n      this._playing = true;\n      if (this._refresh) this.clear();\n\n      if (this._isReady) {\n        for (var k in this.players) {\n          if (this.players[k].animate) this.players[k].animate(time, this._time.diff, this);\n        }\n      }\n\n      if (this._time.end >= 0 && time > this._time.end) {\n        cancelAnimationFrame(this._animID);\n        this._playing = false;\n      }\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this._pause = toggle ? !this._pause : true;\n      return this;\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      this._pause = false;\n      return this;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      this._time.end = t;\n      return this;\n    }\n  }, {\n    key: \"playOnce\",\n    value: function playOnce() {\n      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5000;\n      this.play();\n      this.stop(duration);\n      return this;\n    }\n  }, {\n    key: \"render\",\n    value: function render(context) {\n      if (this._renderFunc) this._renderFunc(context, this);\n      return this;\n    }\n  }, {\n    key: \"customRendering\",\n    set: function set(f) {\n      this._renderFunc = f;\n    },\n    get: function get() {\n      return this._renderFunc;\n    }\n  }, {\n    key: \"isPlaying\",\n    get: function get() {\n      return this._playing;\n    }\n  }, {\n    key: \"outerBound\",\n    get: function get() {\n      return this.bound.clone();\n    }\n  }, {\n    key: \"innerBound\",\n    get: function get() {\n      return new Bound(Pt.make(this.size.length, 0), this.size.clone());\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.bound.size.clone();\n    }\n  }, {\n    key: \"center\",\n    get: function get() {\n      return this.size.divide(2);\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this.bound.width;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.bound.height;\n    }\n  }]);\n\n  return Space;\n}();\nexport var MultiTouchSpace =\n/*#__PURE__*/\nfunction (_Space) {\n  _inherits(MultiTouchSpace, _Space);\n\n  function MultiTouchSpace() {\n    var _this;\n\n    _classCallCheck(this, MultiTouchSpace);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MultiTouchSpace).apply(this, arguments));\n    _this._pressed = false;\n    _this._dragged = false;\n    _this._hasMouse = false;\n    _this._hasTouch = false;\n    return _this;\n  }\n\n  _createClass(MultiTouchSpace, [{\n    key: \"bindCanvas\",\n    value: function bindCanvas(evt, callback) {\n      this._canvas.addEventListener(evt, callback);\n    }\n  }, {\n    key: \"unbindCanvas\",\n    value: function unbindCanvas(evt, callback) {\n      this._canvas.removeEventListener(evt, callback);\n    }\n  }, {\n    key: \"bindMouse\",\n    value: function bindMouse() {\n      var _bind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (_bind) {\n        this.bindCanvas(\"mousedown\", this._mouseDown.bind(this));\n        this.bindCanvas(\"mouseup\", this._mouseUp.bind(this));\n        this.bindCanvas(\"mouseover\", this._mouseOver.bind(this));\n        this.bindCanvas(\"mouseout\", this._mouseOut.bind(this));\n        this.bindCanvas(\"mousemove\", this._mouseMove.bind(this));\n        this._hasMouse = true;\n      } else {\n        this.unbindCanvas(\"mousedown\", this._mouseDown.bind(this));\n        this.unbindCanvas(\"mouseup\", this._mouseUp.bind(this));\n        this.unbindCanvas(\"mouseover\", this._mouseOver.bind(this));\n        this.unbindCanvas(\"mouseout\", this._mouseOut.bind(this));\n        this.unbindCanvas(\"mousemove\", this._mouseMove.bind(this));\n        this._hasMouse = false;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"bindTouch\",\n    value: function bindTouch() {\n      var _bind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (_bind) {\n        this.bindCanvas(\"touchstart\", this._mouseDown.bind(this));\n        this.bindCanvas(\"touchend\", this._mouseUp.bind(this));\n        this.bindCanvas(\"touchmove\", this._touchMove.bind(this));\n        this.bindCanvas(\"touchcancel\", this._mouseOut.bind(this));\n        this._hasTouch = true;\n      } else {\n        this.unbindCanvas(\"touchstart\", this._mouseDown.bind(this));\n        this.unbindCanvas(\"touchend\", this._mouseUp.bind(this));\n        this.unbindCanvas(\"touchmove\", this._touchMove.bind(this));\n        this.unbindCanvas(\"touchcancel\", this._mouseOut.bind(this));\n        this._hasTouch = false;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"touchesToPoints\",\n    value: function touchesToPoints(evt) {\n      var which = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"touches\";\n      if (!evt || !evt[which]) return [];\n      var ts = [];\n\n      for (var i = 0; i < evt[which].length; i++) {\n        var t = evt[which].item(i);\n        ts.push(new Pt(t.pageX - this.bound.topLeft.x, t.pageY - this.bound.topLeft.y));\n      }\n\n      return ts;\n    }\n  }, {\n    key: \"_mouseAction\",\n    value: function _mouseAction(type, evt) {\n      var px = 0,\n          py = 0;\n\n      if (evt instanceof MouseEvent) {\n        for (var k in this.players) {\n          if (this.players.hasOwnProperty(k)) {\n            var v = this.players[k];\n            px = evt.pageX - this.outerBound.x;\n            py = evt.pageY - this.outerBound.y;\n            if (v.action) v.action(type, px, py, evt);\n          }\n        }\n      } else {\n        for (var _k in this.players) {\n          if (this.players.hasOwnProperty(_k)) {\n            var _v = this.players[_k];\n            var c = evt.changedTouches && evt.changedTouches.length > 0;\n            var touch = evt.changedTouches.item(0);\n            px = c ? touch.pageX - this.outerBound.x : 0;\n            py = c ? touch.pageY - this.outerBound.y : 0;\n            if (_v.action) _v.action(type, px, py, evt);\n          }\n        }\n      }\n\n      if (type) {\n        this._pointer.to(px, py);\n\n        this._pointer.id = type;\n      }\n    }\n  }, {\n    key: \"_mouseDown\",\n    value: function _mouseDown(evt) {\n      this._mouseAction(UIA.down, evt);\n\n      this._pressed = true;\n      return false;\n    }\n  }, {\n    key: \"_mouseUp\",\n    value: function _mouseUp(evt) {\n      this._mouseAction(UIA.up, evt);\n\n      if (this._dragged) this._mouseAction(UIA.drop, evt);\n      this._pressed = false;\n      this._dragged = false;\n      return false;\n    }\n  }, {\n    key: \"_mouseMove\",\n    value: function _mouseMove(evt) {\n      this._mouseAction(UIA.move, evt);\n\n      if (this._pressed) {\n        this._dragged = true;\n\n        this._mouseAction(UIA.drag, evt);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_mouseOver\",\n    value: function _mouseOver(evt) {\n      this._mouseAction(UIA.over, evt);\n\n      return false;\n    }\n  }, {\n    key: \"_mouseOut\",\n    value: function _mouseOut(evt) {\n      this._mouseAction(UIA.out, evt);\n\n      if (this._dragged) this._mouseAction(UIA.drop, evt);\n      this._dragged = false;\n      return false;\n    }\n  }, {\n    key: \"_touchMove\",\n    value: function _touchMove(evt) {\n      this._mouseMove(evt);\n\n      evt.preventDefault();\n      return false;\n    }\n  }, {\n    key: \"pointer\",\n    get: function get() {\n      var p = this._pointer.clone();\n\n      p.id = this._pointer.id;\n      return p;\n    }\n  }]);\n\n  return MultiTouchSpace;\n}(Space);","map":null,"metadata":{},"sourceType":"module"}