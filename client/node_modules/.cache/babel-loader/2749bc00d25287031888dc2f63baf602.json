{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _construct from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/construct\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _classCallCheck from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\ori saida\\\\Desktop\\\\OriHub\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/*! Source code licensed under Apache License 2.0. Copyright Â© 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Pt, Group, Bound } from \"./Pt\";\nimport { Polygon, Circle } from \"./Op\";\nexport var World =\n/*#__PURE__*/\nfunction () {\n  function World(bound) {\n    var friction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var gravity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, World);\n\n    this._lastTime = null;\n    this._gravity = new Pt();\n    this._friction = 1;\n    this._damping = 0.75;\n    this._particles = [];\n    this._bodies = [];\n    this._pnames = [];\n    this._bnames = [];\n    this._bound = Bound.fromGroup(bound);\n    this._friction = friction;\n    this._gravity = typeof gravity === \"number\" ? new Pt(0, gravity) : new Pt(gravity);\n    return this;\n  }\n\n  _createClass(World, [{\n    key: \"body\",\n    value: function body(id) {\n      var idx = id;\n\n      if (typeof id === \"string\" && id.length > 0) {\n        idx = this._bnames.indexOf(id);\n      }\n\n      if (!(idx >= 0)) return undefined;\n      return this._bodies[idx];\n    }\n  }, {\n    key: \"particle\",\n    value: function particle(id) {\n      var idx = id;\n\n      if (typeof id === \"string\" && id.length > 0) {\n        idx = this._pnames.indexOf(id);\n      }\n\n      if (!(idx >= 0)) return undefined;\n      return this._particles[idx];\n    }\n  }, {\n    key: \"bodyIndex\",\n    value: function bodyIndex(name) {\n      return this._bnames.indexOf(name);\n    }\n  }, {\n    key: \"particleIndex\",\n    value: function particleIndex(name) {\n      return this._pnames.indexOf(name);\n    }\n  }, {\n    key: \"update\",\n    value: function update(ms) {\n      var dt = ms / 1000;\n\n      this._updateParticles(dt);\n\n      this._updateBodies(dt);\n    }\n  }, {\n    key: \"drawParticles\",\n    value: function drawParticles(fn) {\n      this._drawParticles = fn;\n    }\n  }, {\n    key: \"drawBodies\",\n    value: function drawBodies(fn) {\n      this._drawBodies = fn;\n    }\n  }, {\n    key: \"add\",\n    value: function add(p) {\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n      if (p instanceof Body) {\n        this._bodies.push(p);\n\n        this._bnames.push(name);\n      } else {\n        this._particles.push(p);\n\n        this._pnames.push(name);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_index\",\n    value: function _index(fn, id) {\n      var index = 0;\n\n      if (typeof id === \"string\") {\n        index = fn(id);\n        if (index < 0) throw new Error(\"Cannot find index of \".concat(id, \". You can use particleIndex() or bodyIndex() function to check existence by name.\"));\n      } else {\n        index = id;\n      }\n\n      return index;\n    }\n  }, {\n    key: \"removeBody\",\n    value: function removeBody(from) {\n      var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      var index = this._index(this.bodyIndex.bind(this), from);\n\n      var param = index < 0 ? [index * -1 - 1, count] : [index, count];\n\n      this._bodies.splice(param[0], param[1]);\n\n      this._bnames.splice(param[0], param[1]);\n\n      return this;\n    }\n  }, {\n    key: \"removeParticle\",\n    value: function removeParticle(from) {\n      var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      var index = this._index(this.particleIndex.bind(this), from);\n\n      var param = index < 0 ? [index * -1 - 1, count] : [index, count];\n\n      this._particles.splice(param[0], param[1]);\n\n      this._pnames.splice(param[0], param[1]);\n\n      return this;\n    }\n  }, {\n    key: \"integrate\",\n    value: function integrate(p, dt, prevDt) {\n      p.addForce(this._gravity);\n      p.verlet(dt, this._friction, prevDt);\n      return p;\n    }\n  }, {\n    key: \"_updateParticles\",\n    value: function _updateParticles(dt) {\n      for (var i = 0, len = this._particles.length; i < len; i++) {\n        var p = this._particles[i];\n        this.integrate(p, dt, this._lastTime);\n        World.boundConstraint(p, this._bound, this._damping);\n\n        for (var k = i + 1; k < len; k++) {\n          if (i !== k) {\n            var p2 = this._particles[k];\n            p.collide(p2, this._damping);\n          }\n        }\n\n        if (this._drawParticles) this._drawParticles(p, i);\n      }\n\n      this._lastTime = dt;\n    }\n  }, {\n    key: \"_updateBodies\",\n    value: function _updateBodies(dt) {\n      for (var i = 0, len = this._bodies.length; i < len; i++) {\n        var bds = this._bodies[i];\n\n        if (bds) {\n          for (var k = 0, klen = bds.length; k < klen; k++) {\n            var bk = bds[k];\n            World.boundConstraint(bk, this._bound, this._damping);\n            this.integrate(bk, dt, this._lastTime);\n          }\n\n          for (var _k = i + 1; _k < len; _k++) {\n            bds.processBody(this._bodies[_k]);\n          }\n\n          for (var m = 0, mlen = this._particles.length; m < mlen; m++) {\n            bds.processParticle(this._particles[m]);\n          }\n\n          bds.processEdges();\n          if (this._drawBodies) this._drawBodies(bds, i);\n        }\n      }\n    }\n  }, {\n    key: \"bound\",\n    get: function get() {\n      return this._bound;\n    },\n    set: function set(bound) {\n      this._bound = bound;\n    }\n  }, {\n    key: \"gravity\",\n    get: function get() {\n      return this._gravity;\n    },\n    set: function set(g) {\n      this._gravity = g;\n    }\n  }, {\n    key: \"friction\",\n    get: function get() {\n      return this._friction;\n    },\n    set: function set(f) {\n      this._friction = f;\n    }\n  }, {\n    key: \"damping\",\n    get: function get() {\n      return this._damping;\n    },\n    set: function set(f) {\n      this._damping = f;\n    }\n  }, {\n    key: \"bodyCount\",\n    get: function get() {\n      return this._bodies.length;\n    }\n  }, {\n    key: \"particleCount\",\n    get: function get() {\n      return this._particles.length;\n    }\n  }], [{\n    key: \"edgeConstraint\",\n    value: function edgeConstraint(p1, p2, dist) {\n      var stiff = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      var precise = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var m1 = 1 / (p1.mass || 1);\n      var m2 = 1 / (p2.mass || 1);\n      var mm = m1 + m2;\n      var delta = p2.$subtract(p1);\n      var distSq = dist * dist;\n      var d = precise ? dist / delta.magnitude() - 1 : distSq / (delta.dot(delta) + distSq) - 0.5;\n      var f = delta.$multiply(d * stiff);\n      p1.subtract(f.$multiply(m1 / mm));\n      p2.add(f.$multiply(m2 / mm));\n      return p1;\n    }\n  }, {\n    key: \"boundConstraint\",\n    value: function boundConstraint(p, rect) {\n      var damping = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.75;\n      var bound = rect.boundingBox();\n      var np = p.$min(bound[1].subtract(p.radius)).$max(bound[0].add(p.radius));\n\n      if (np[0] === bound[0][0] || np[0] === bound[1][0]) {\n        var c = p.changed.$multiply(damping);\n        p.previous = np.$subtract(new Pt(-c[0], c[1]));\n      } else if (np[1] === bound[0][1] || np[1] === bound[1][1]) {\n        var _c = p.changed.$multiply(damping);\n\n        p.previous = np.$subtract(new Pt(_c[0], -_c[1]));\n      }\n\n      p.to(np);\n    }\n  }]);\n\n  return World;\n}();\nexport var Particle =\n/*#__PURE__*/\nfunction (_Pt) {\n  _inherits(Particle, _Pt);\n\n  function Particle() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, Particle);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Particle)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this._mass = 1;\n    _this._radius = 0;\n    _this._force = new Pt();\n    _this._prev = new Pt();\n    _this._lock = false;\n    _this._prev = _this.clone();\n    return _this;\n  }\n\n  _createClass(Particle, [{\n    key: \"size\",\n    value: function size(r) {\n      this._mass = r;\n      this._radius = r;\n      return this;\n    }\n  }, {\n    key: \"addForce\",\n    value: function addForce() {\n      var _this$_force;\n\n      (_this$_force = this._force).add.apply(_this$_force, arguments);\n\n      return this._force;\n    }\n  }, {\n    key: \"verlet\",\n    value: function verlet(dt, friction, lastDt) {\n      if (this._lock) {\n        this.to(this._lockPt);\n      } else {\n        var lt = lastDt ? lastDt : dt;\n\n        var a = this._force.multiply(dt * (dt + lt) / 2);\n\n        var v = this.changed.multiply(friction * dt / lt).add(a);\n        this._prev = this.clone();\n        this.add(v);\n        this._force = new Pt();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"hit\",\n    value: function hit() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      this._prev.subtract(_construct(Pt, args).$divide(Math.sqrt(this._mass)));\n\n      return this;\n    }\n  }, {\n    key: \"collide\",\n    value: function collide(p2) {\n      var damp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var p1 = this;\n      var dp = p1.$subtract(p2);\n      var distSq = dp.magnitudeSq();\n      var dr = p1.radius + p2.radius;\n\n      if (distSq < dr * dr) {\n        var c1 = p1.changed;\n        var c2 = p2.changed;\n        var dist = Math.sqrt(distSq);\n        var d = dp.$multiply((dist - dr) / dist / 2);\n        var np1 = p1.$subtract(d);\n        var np2 = p2.$add(d);\n        p1.to(np1);\n        p2.to(np2);\n        var f1 = damp * dp.dot(c1) / distSq;\n        var f2 = damp * dp.dot(c2) / distSq;\n        var dm1 = p1.mass / (p1.mass + p2.mass);\n        var dm2 = p2.mass / (p1.mass + p2.mass);\n        c1.add(new Pt(f2 * dp[0] - f1 * dp[0], f2 * dp[1] - f1 * dp[1]).$multiply(dm2));\n        c2.add(new Pt(f1 * dp[0] - f2 * dp[0], f1 * dp[1] - f2 * dp[1]).$multiply(dm1));\n        p1.previous = p1.$subtract(c1);\n        p2.previous = p2.$subtract(c2);\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Particle: \".concat(this[0], \" \").concat(this[1], \" | previous \").concat(this._prev[0], \" \").concat(this._prev[1], \" | mass \").concat(this._mass);\n    }\n  }, {\n    key: \"mass\",\n    get: function get() {\n      return this._mass;\n    },\n    set: function set(m) {\n      this._mass = m;\n    }\n  }, {\n    key: \"radius\",\n    get: function get() {\n      return this._radius;\n    },\n    set: function set(f) {\n      this._radius = f;\n    }\n  }, {\n    key: \"previous\",\n    get: function get() {\n      return this._prev;\n    },\n    set: function set(p) {\n      this._prev = p;\n    }\n  }, {\n    key: \"force\",\n    get: function get() {\n      return this._force;\n    },\n    set: function set(g) {\n      this._force = g;\n    }\n  }, {\n    key: \"body\",\n    get: function get() {\n      return this._body;\n    },\n    set: function set(b) {\n      this._body = b;\n    }\n  }, {\n    key: \"lock\",\n    get: function get() {\n      return this._lock;\n    },\n    set: function set(b) {\n      this._lock = b;\n      this._lockPt = new Pt(this);\n    }\n  }, {\n    key: \"changed\",\n    get: function get() {\n      return this.$subtract(this._prev);\n    }\n  }, {\n    key: \"position\",\n    set: function set(p) {\n      this.previous.to(this);\n      if (this._lock) this._lockPt = p;\n      this.to(p);\n    }\n  }]);\n\n  return Particle;\n}(Pt);\nexport var Body =\n/*#__PURE__*/\nfunction (_Group) {\n  _inherits(Body, _Group);\n\n  function Body() {\n    var _this2;\n\n    _classCallCheck(this, Body);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Body).call(this));\n    _this2._cs = [];\n    _this2._stiff = 1;\n    _this2._locks = {};\n    _this2._mass = 1;\n    return _this2;\n  }\n\n  _createClass(Body, [{\n    key: \"init\",\n    value: function init(list) {\n      var stiff = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var c = new Pt();\n\n      for (var i = 0, len = list.length; i < len; i++) {\n        var p = new Particle(list[i]);\n        p.body = this;\n        c.add(list[i]);\n        this.push(p);\n      }\n\n      this._stiff = stiff;\n      return this;\n    }\n  }, {\n    key: \"autoMass\",\n    value: function autoMass() {\n      this.mass = Math.sqrt(Polygon.area(this)) / 10;\n      return this;\n    }\n  }, {\n    key: \"link\",\n    value: function link(index1, index2, stiff) {\n      if (index1 < 0 || index1 >= this.length) throw new Error(\"index1 is not in the Group's indices\");\n      if (index2 < 0 || index2 >= this.length) throw new Error(\"index1 is not in the Group's indices\");\n      var d = this[index1].$subtract(this[index2]).magnitude();\n\n      this._cs.push([index1, index2, d, stiff || this._stiff]);\n\n      return this;\n    }\n  }, {\n    key: \"linkAll\",\n    value: function linkAll(stiff) {\n      var half = this.length / 2;\n\n      for (var i = 0, len = this.length; i < len; i++) {\n        var n = i >= len - 1 ? 0 : i + 1;\n        this.link(i, n, stiff);\n\n        if (len > 4) {\n          var nd = Math.floor(half / 2) + 1;\n          var n2 = i >= len - nd ? i % len : i + nd;\n          this.link(i, n2, stiff);\n        }\n\n        if (i <= half - 1) {\n          this.link(i, Math.min(this.length - 1, i + Math.floor(half)));\n        }\n      }\n    }\n  }, {\n    key: \"linksToLines\",\n    value: function linksToLines() {\n      var gs = [];\n\n      for (var i = 0, len = this._cs.length; i < len; i++) {\n        var ln = this._cs[i];\n        gs.push(new Group(this[ln[0]], this[ln[1]]));\n      }\n\n      return gs;\n    }\n  }, {\n    key: \"processEdges\",\n    value: function processEdges() {\n      for (var i = 0, len = this._cs.length; i < len; i++) {\n        var _this$_cs$i = _slicedToArray(this._cs[i], 4),\n            m = _this$_cs$i[0],\n            n = _this$_cs$i[1],\n            d = _this$_cs$i[2],\n            s = _this$_cs$i[3];\n\n        World.edgeConstraint(this[m], this[n], d, s);\n      }\n    }\n  }, {\n    key: \"processBody\",\n    value: function processBody(b) {\n      var b1 = this;\n      var b2 = b;\n      var hit = Polygon.hasIntersectPolygon(b1, b2);\n\n      if (hit) {\n        var cv = hit.normal.$multiply(hit.dist);\n        var t;\n        var eg = hit.edge;\n\n        if (Math.abs(eg[0][0] - eg[1][0]) > Math.abs(eg[0][1] - eg[1][1])) {\n          t = (hit.vertex[0] - cv[0] - eg[0][0]) / (eg[1][0] - eg[0][0]);\n        } else {\n          t = (hit.vertex[1] - cv[1] - eg[0][1]) / (eg[1][1] - eg[0][1]);\n        }\n\n        var lambda = 1 / (t * t + (1 - t) * (1 - t));\n        var m0 = hit.vertex.body.mass || 1;\n        var m1 = hit.edge[0].body.mass || 1;\n        var mr0 = m0 / (m0 + m1);\n        var mr1 = m1 / (m0 + m1);\n        eg[0].subtract(cv.$multiply(mr0 * (1 - t) * lambda / 2));\n        eg[1].subtract(cv.$multiply(mr0 * t * lambda / 2));\n        hit.vertex.add(cv.$multiply(mr1));\n      }\n    }\n  }, {\n    key: \"processParticle\",\n    value: function processParticle(b) {\n      var b1 = this;\n      var b2 = b;\n      var hit = Polygon.hasIntersectCircle(b1, Circle.fromCenter(b, b.radius));\n\n      if (hit) {\n        var cv = hit.normal.$multiply(hit.dist);\n        var t;\n        var eg = hit.edge;\n\n        if (Math.abs(eg[0][0] - eg[1][0]) > Math.abs(eg[0][1] - eg[1][1])) {\n          t = (hit.vertex[0] - cv[0] - eg[0][0]) / (eg[1][0] - eg[0][0]);\n        } else {\n          t = (hit.vertex[1] - cv[1] - eg[0][1]) / (eg[1][1] - eg[0][1]);\n        }\n\n        var lambda = 1 / (t * t + (1 - t) * (1 - t));\n        var m0 = hit.vertex.mass || b2.mass || 1;\n        var m1 = hit.edge[0].body.mass || 1;\n        var mr0 = m0 / (m0 + m1);\n        var mr1 = m1 / (m0 + m1);\n        eg[0].subtract(cv.$multiply(mr0 * (1 - t) * lambda / 2));\n        eg[1].subtract(cv.$multiply(mr0 * t * lambda / 2));\n        var c1 = b.changed.add(cv.$multiply(mr1));\n        b.previous = b.$subtract(c1);\n      }\n    }\n  }, {\n    key: \"mass\",\n    get: function get() {\n      return this._mass;\n    },\n    set: function set(m) {\n      this._mass = m;\n\n      for (var i = 0, len = this.length; i < len; i++) {\n        this[i].mass = this._mass;\n      }\n    }\n  }], [{\n    key: \"fromGroup\",\n    value: function fromGroup(list) {\n      var stiff = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var autoLink = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var autoMass = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var b = new Body().init(list);\n      if (autoLink) b.linkAll(stiff);\n      if (autoMass) b.autoMass();\n      return b;\n    }\n  }]);\n\n  return Body;\n}(Group);","map":null,"metadata":{},"sourceType":"module"}